%%% Фајл:     b03_Commands.mkiv
%%% Аутор:    Joaquín Ataz-López
%%% Започето: Април 2020
%%% Завршено: Април 2020
%%% Садржај:  Ово је главно поглавље за разумевање суштине система
%%%	      ConTeXt. Један део његовог садржаја је заснован на TeX.
%%%	      Употреба резервисаних карактера и разлика између
%%%	      контролних симбола и контролних речи. Кнут инстистра на
%%%	      разлици, али то не раде ни ConTeXt документација, ни у
%%%	      општем случају LaTeX документација (осим кратке референце
%%%	      у књизи Копке). Ја ипак сматрам да је она важна за
%%%	      разумевање зашто се у именима TeX команди не мешају слова
%%%	      и остали знаци који нису слова. Што се тиче објашњења
%%%	      команди, има одлука у вези са »start-stop« конструкцијама
%%%	      које још увек оклевам да називам »окружење«. Али понекад
%%%	      то раде на викију. С друге стране, задовољан сам својим
%%%	      објашњењем за \setup + \define употребом команде \framed
%%%	      као примера.  Од осталих ствари, желео бих да уведем и
%%%	      бројаче, али нисам пронашао никакву документацију у вези
%%%	      имена главних бројача у систему ConTeXt. На пример, урадио
%%%	      сам разне тестове ручне манипулације бројачима поглавља и…
%%%	      бум. Велико ништа. Ова информација, од изузетне важности
%%%	      за контролисање система ConTeXt, требало би да се
%%%	      експлицитно наведе негде.
%%%
%%% Уређивано са: Emacs + AuTeX - и повремено са vim + context-plugin
%%%

% \environment ../introCTX_env.mkiv

\startcomponent b03_Commands.mkiv

\startchapter
  [
    reference=cap:commands,
    title=Команде и остали фундаментални концепти система \ConTeXt,
    bookmark=Команде и остали фундаментални концепти система ConTeXt,
  ]

\TocChap

Већ смо видели да се у изворном фајлу, као и у самом садржају нашег
будућег форматираног документа, налазе инструкције које систему
\ConTeXt\ објашњавају како желимо да се наш рукопис трансформише.  Ове
инструкције можемо да назовемо \quotation{команде}, \quotation{макрои}
или \quotation{контролни низови}.

\startSmallPrint

  Из угла интерног функционисања система \ConTeXt\ (то јест
  функционисања система \TeX), постоји разлика између {\em примитива} и
  {\em макроа}. Примитива је једноставна инструкција која не може да се
  разбије у друге једноставније инструкције. Макро је инструкција која
  се разбија у друге једноставније инструкције, које можда такође могу
  да се разбију у друге једноставније и тако редом.  Већина \ConTeXt\
  инструкција су, у ствари, макрои. Из перспективе програмера, разлика
  између макроа и примитива је важна. Али из перспективе корисника ствар
  није тако битна: у оба случаја имамо инструкције које се извршавају
  без потребе да водимо рачуна о начину на који оне функционишу на
  ниском нивоу.  Стога, \ConTeXt\ документација обично говори о {\em
  команди} када посматра из угла корисника, а {\em макроу} када говори
  из угла програмера. Пошто у овом уводу говоримо само из угла
  корисника, ја ћу користити било који од ова два израза и посматраћу их
  као да су синоними.

  {\em Команде} су налози којима се систему \ConTeXt\ говори да нешто
  уради; њима ми {\em контролишемо} ефекат програма. Тако да \cap{Кнут},
  отац система \TeX, користи израз {\em контролни низови} када мисли и
  на примитиве и на макрое, и ја мислим да је то најпрецизнији од свих
  израза.  Користићу га када верујем да је важно направити разлику
  између {\em контролних симбола} и {\em контролних речи}.

\stopSmallPrint

\ConTeXt\ инструкције могу у основи да буду или резервисани карактери,
или команде у ужем смислу.

\startsection
  [
    reference=sec:reserved characters,
    title=\ConTeXt\ резервисани карактери,
    bookmark=ConTeXt резервисани карактери,
  ]

Када \ConTeXt\ чита изворни фајл састављен само од текст карактера, а
пошто је то чист текст, потребно је на неки начин разликовати текст који
треба да се форматира од инструкција које се извршавају над њим.
\ConTeXt\ резервисани карактери омогућавају то разликовање. У принципу,
\ConTeXt\ ће претпоставити да сваки карактер у фајлу треба да се обради,
осим ако није један од 11 резервисаних карактера који треба да се
третирају као {\em инструкција}.

Само 11 инструкција? Не. Постоји само 11 резервисаних карактера; али
пошто један од њих, карактер \quotation{{\tt\backslash}}, има функцију
конвертовања карактера или више њих који му непосредно следе у
инструкцију, онда је у суштини потенцијални број команди практично
неограничен. \ConTeXt\ поседује око 3000 команди (кад се саберу команде
које постоје само у Mark~II, Mark~IV и оне заједничке за обе верзије).

Ово су резервисани карактери: 

{
  \switchtobodyfont[25pt]
  \midaligned{\cmd{ \% \{ \} \# \lettertilde\ \| \$ \_ \letterhat\ \&}}
}

\ConTeXt\ их интерпретира на следећи начин:

\semitable{\backslash}

Ово је за нас најзначајнији карактер: он означава да све што следи
непосредно након њега не сме да се интерпретира као текст већ као
инструкција.  Он се назива \quotation{Означавајући (Escape) карактер}
или \quotation{Означавајући низ} (мада нема никакве везе са
\quotation{Esc} тастером који се налази на већини тастатура).\footnote{У
компјутерској терминологији се тастер који утиче на интерпретацију
наредног карактера назива {\em escape (означавајући) карактер}. За
разлику од тога, {\em escape тастер} се на тастатурама тако назива јер
генерише карактер 27 у ASCII коду, који се у овом кодирању употребљава
као escape карактер. Данас се употреба Escape тастера повезује са идејом
отказивања текуће операције.}

\semitable{\%}

Говори систему \ConTeXt\ да је све оно што следи до краја линије
коментар који не сме да се обрађује или укључи у финални форматирани
фајл.  Уметање коментара у изворни фајл је изузетно корисно. Коментар
може помоћи да се објасни зашто је нешто урађено на одређени начин, а то
је заиста корисно у завршеним изворним фајловима у смислу каснијих
ревизија, када понекад не можемо да се сетимо зашто смо нешто урадили
онако како смо урадили; или такође може да послужи као подсетник о
нечему што би можда требало да прерадимо.  Може чак да се употреби као
помоћ за лоцирање одређене грешке у изворном фајлу, јер се постављањем
знака коментара на почетак линије она не компајлира, па можемо видети да
ли је та линија била узрок грешке; такође може да се користи за чување
две различите верзије истог макроа, па да на тај начин добијемо
различите резултате након компајлирања; или да спречи компајлирање
фрагмента за који нисмо сигурни, а да га не обришемо из изворног
фајла, у случају да касније желимо да се вратимо на њега… итд. Једном
кад добијемо могућност да изворни фајл садржи текст који само ми видимо
и нико други, употреба овог карактера је ограничена само нашом
сопственом маштом.  Признајем да је ово једна од могућности која ми
највише недостаје онда када је једини начин за писање текста употреба
текст процесора.

\semitable{\{}

Овај карактер отвара групу. Групе су блокови текста на које утичу
одређене могућности. О њима ћемо говорити у \in{одељку}[sec:groups].

\semitable{\}}

Овај карактер затвара групу претходно отворену са {\tt \{}.

\semitable{\#}

Овај карактер се користи за дефиницију макроа. Он указује на аргументе
макроа. Погледајте \in{одељак}[sec:define] у овом поглављу.

\semitable{\lettertilde}

Уноси размак у документ који спречава прелом линије, што значи да ће две
речи раздвојене карактером \type{~} увек бити у истој линији.  О овој
инструкцији и местима на којима би требало да се употреби ћемо говорити
у \in{одељку}[sec:lettertilde].

\semitable{\|}

Овај карактер се користи за означавање да две речи спојене раздвајајућим
елементом праве сложену реч која може да се подели на слогове у прву
компоненту, али не у другу компоненту. Погледајте
\in{одељак}[sec:compound words].

\semitable{\$}

Овај карактер је прекидач за математички режим. Он га укључује ако је
био искључен, или га искључује ако је био укључен. Када се налази у
математичком режиму, \ConTeXt\ примењује неке фонтове и правила која се
разликују од уобичајених, чији је циљ оптимизација писања математичких
формула.  Мада је писање математике веома битна употреба система
\ConTeXt, ја о томе нећу детаљно говорити у овом уводу. Пошто сам писац,
није ми до тога!

\semitable{\_}

Овај карактер се користи да у математичком режиму означи да је оно што
следи исписано у индексу.  На пример, да бисмо добили $x_1$, морамо да
напишемо \type{$x_1$}.

\semitable{\letterhat}

Овај карактер се користи да у математичком режиму означи да је оно што
следи исписано у експоненту. На пример, да бисмо добили $(x+i)^{n^3}$
потребно је да напишемо \type{$(x+i)^{n^3}$}.

\semitable{\&}

У \ConTeXt\ документацији пише да је ово резервисан карактер, али се не
каже зашто. У Plain \TeX\ овај карактер има у суштини две употребе:
користи се да поравна колоне у окружењима основне табеле, а у
математичком контексту да оно што следи треба да се третира као обичан
текст.  У уводном упутству \quotation{\ConTeXt\ Mark~IV, an Excursion},
мада не пише за шта служи, постоје примери његове употребе у
математичким формулама, додуше не онако како се користи у Plain \TeX,
већ да поравна колоне унутар \Doubt комплексних функција.  Пошто сам ја
писац, мислим да не могу обавити додатна тестирања којима могу сазнати
за шта се тачно користи овај резервисани карактер.

Може се претпоставити да се при избору карактера који би требало да буду
резервисани водило рачуна да то буду карактери доступни на већини
тастатура, али они који се обично не користе у писаном језику.  Међутим,
мада није тако уобичајено, увек постоји могућност да се неки од њих
појави у нашим документима, као на пример, када желимо да напишемо да
нешто кошта 100 долара (\$100), или да је у Шпанији 2018. године
проценат возача преко 65 година старости био 16\%. У овим случајевима не
смемо директно да пишемо резервисани карактер, већ морамо да користимо
{\em команду} која ће исправно исписати резервисани карактер у финални
документ. Команда за сваки резервисани карактер може да се пронађе у
\in{табели}[Резервисани карактери].

\placetable
  [here]
  [Резервисани карактери]
  {\tfx Писање резервисаних карактера}
{\starttabulate[|c|l|]
  \HL
  \NC {\bf Резервисани карактер} \NC {\bf Команда која га генерише}\NR
  \HL
  \NC{\tt
    \backslash}\NC\PlaceMacro{backslash}\tex{backslash}\NR\macro{резервисани карактери+\backslash backslash}
  \NC{\tt \%}\NC{\cmd{\%}}\NR\macro{резервисани карактери+\backslash \%}
  \NC{\tt \{}\NC\cmd{\{}\NR\macro{резервисани карактери+\backslash \{}
  \NC{\tt \}}\NC\cmd{\}}\NR\macro{резервисани карактери+\backslash \}}
  \NC{\tt \#}\NC\cmd{\#}\NR\macro{резервисани карактери+\backslash \#}
  \NC{\tt \lettertilde}\NC\PlaceMacro{lettertilde}\tex{lettertilde}\NR\macro{резервисани карактери+\backslash lettertilde}
  \NC{\tt \|}\NC\cmd{\|}\NR\macro{резервисани карактери+\backslash \|}
  \NC{\tt \$}\NC\cmd{\$}\NR\macro{резервисани карактери+\backslash \$}
  \NC{\tt \_}\NC\cmd{\_}\NR\macro{резервисани карактери+\backslash \_}
  \NC{\tt \letterhat}\NC\PlaceMacro{letterhat}\tex{letterhat}\NR\macro{резервисани карактери+\backslash letterhat}
  \NC{\tt \&}\NC\cmd{\&}\macro{резервисани карактери+\backslash \&}\NR
  \HL
\stoptabulate}

Још један начин за добијање резервисаног карактера је командом
\tex{type}. Ова команда шаље свој аргумент у финални документ без било
какве обраде, дакле и без интерпретирања. Текст који се прими из
\tex{type} ће у финалном документу да се прикаже фонтом фиксне ширине
који је типичан за компјутерске терминале и писаће машине.

\startSmallPrint

  Обично бисмо текст који \tex{type} треба да прикаже окружили
  витичастим заградама. Међутим, када тај текст и сам садржи отварајуће
  или затварајуће витичасте заграде, уместо у њих, текст морамо да
  окружимо са два иста карактера која нису део текста који чини аргумент
  команде \tex{type}. На пример: \cmd{type*\{*}, или \cmd{type+\}+}.

\stopSmallPrint

Ако неки од ових карактера грешком употребимо директно, а не за оно за
шта је предвиђен, него зато што смо заборавили да резервисани карактер
не може да се користи као обичан, могу да се догоде три ствари:

\startitemize[n]

  \item У највећем броју случајева, грешка приликом компајлирања.

  \item Добијемо неочекивани резултат. Ово се дешава посебно са
  \MyKey{\lettertilde} и \MyKey{\%}; у првом случају, уместо
  \MyKey{\lettertilde} који смо очекивали у финалном документу, уметнуће
  се размак; а у другом случају, све након карактера \MyKey{\%} у тој
  линији ће престати да се обрађује.  Неправилна употреба
  \quotation{{\tt\backslash}} такође може да има неочекивани резултат
  ако он или карактери непосредно иза творе команду коју \ConTeXt\
  разуме.  Међутим, неправилна употреба \quotation{{\tt\backslash}}
  много чешће доводи до грешке у компајлирању.

  \item Не долази до проблема: ово се дешава са три резервисана
  карактера који се углавном користе у математици ({\tt _ ^ &}): ако се
  користе ван овог окружења, они се третирају као обични карактери.

  \startSmallPrint

    Трећа тачка је мој закључак. Истина је да нигде у \ConTeXt\
    документацији нисам пронашао где ове резервисане карактере можемо
    директно да користимо; \Conjecture{} међутим, у мојим тестовима
    нисам наишао на грешку када се ово уради; за разлику од, на пример,
    система \LaTeX.

  \stopSmallPrint

\stopitemize

\stopsection

\startsection
  [
    title=Саме команде,
    reference=sec:commands themselves,
  ]

Саме команде увек почињу карактером \quotation{{\tt\backslash}}.  У
зависности од онога што долази непосредно иза означавајућег низа, прави се
разлика између:

\startitemize[azbuka]

  \item {\bf Контролних симбола.} Контролни симбол почиње означавајућим
  низом (\quotation{{\tt\backslash}}) и састоји се само од карактера
  који нису слова, као на пример\quotation{\tex{,}},
  \quotation{\tex{1}}, \quotation{\tex{'}} или \quotation{\type{\%}}.
  Контролни симбол може бити било који карактер или симбол који није
  слово у буквалном смислу, укључујући бројеве, знаке интерпункције,
  симболе, па чак и размак.  Када је потребно да се у овом документу
  истакне присуство размака (празног простора), користим
  симбол~{\ss\thinspace\textvisiblespace\thinspace}. Уствари, као што ћемо ускоро да
  видимо, \quotation{\cmd{\textvisiblespace}} (обрнута коса црта након
  које следи размак) је контролни симбол који се често користи, што ћемо
  ускоро видети.

  \startSmallPrint

    \reference[note:invisible space]{}Празнина или размак је
    \quotation{невидљиви} карактер који у документима као што је овај
    представља проблем када постоји потреба да се јасно наведе шта треба
    да се упише у изворни фајл. {\sc Кнут} је и сам био свестан
    проблема, па је у својој књизи \quotation{The \TeX Book} увео обичај
    представљања значајних размака симболом
    \quotation{\thinspace\textvisiblespace\thinspace}. Дакле, када је
    хтео да покаже да су две речи у изворном фајлу раздвојени са два
    размака, онда је писао
    \quotation{{реч1\thinspace\textvisiblespace\thinspace\
    \textvisiblespace\thinspace реч2}}.
    
  \stopSmallPrint

  \item {\bf Контролних речи.} Ако је карактер који следи непосредно иза
  обрнуте косе црте слово у ужем смислу, команда ће представљати {\em
  Контролну реч}. Ова група команди је најбројнија од свих и њена
  особина је да имена команди смеју да се састоје само од слова;
  бројеви, знаци интерпункције или било који други симболи нису
  дозвољени.  Само мала и велика слова. Имајте на уму да \ConTeXt\ прави
  разлику између малих и великих слова, што значи да су
  \tex{mojakomanda} и \tex{MojaKomanda} две различите команде.  Али би
  се сматрало да су \tex{MojaKomanda1} и \tex{MojaKomanda2} исте
  команде, јер како \quote{1} и \quote{2} нису слова, они нису део имена
  команде.

  \startSmallPrint

    \ConTeXt\ референтно упутство не садржи правила у вези са именима
    команди, као ни остала \quotation{упутства} која су део
    \Conjecture\suite-. Оно што сам навео у претходном пасусу је мој
    закључак заснован на ономе што се дешава у \TeX\ (где се, на пример,
    акцентовани карактери који нису део енглеског алфабета не сматрају
    за \quotation{слова}). Ово правило омогућава да се на добар начин
    објасни нестајање размака након имена команде.

  \stopSmallPrint

\stopitemize

Када \ConTeXt\ чита изворни фајл и наиђе на означавајући карактер
(\quotation{{\tt\backslash}}), он зна да следи команда. Затим чита први
карактер након означавајућег низа. Ако он није слово, то значи да је
команда контролни симбол и да се састоји само од тог првог симбола. Али
с друге стране, ако је први карактер након означавајућег низа слово,
\ConTeXt\ ће онда наставити да чита сваки наредни карактер све док не
наиђе на први који није слово, па онда зна да је име команде завршено.
Ово је разлог што имена команди која су контролне речи не могу да садрже
карактере који нису слова.

Када је \quotation{не-слово} на крају имена команде размак, претпоставља
се да тај размак није део текста који треба да се обради, већ да је
уметнут само да се назначи крај имена команде, тако да \ConTeXt\
игнорише овај размак. Ово понашање изненађује \ConTeXt\ почетнике, јер
када је ефекат команде да се нешто пише у финални документ, писани излаз
команде се везује за наредну реч. На пример, следеће две реченице у
изворном фајлу

{\switchtobodyfont[small]
\starttyping
Познавање \TeX помаже да се научи \ConTeXt.
Познавање \TeX, мада није обавезно, помаже да се научи \ConTeXt
\stoptyping
}

редом производе следеће резултате:

{ \tfx\color[red]{Познавање \TeX помаже да се научи \ConTeXt.\\ %
Познавање \TeX, мада није обавезно, помаже да се научи \ConTeXt.%
}\footnote{{\bf Напомена:} у случајевима када у овом уводу треба да се
нешто илуструје, писаће се фрагмент кода као и резултат његовог
компајлирања користећи једну од две конвенције: понекад су кôд и
резултат његовог компајлирања постављени један уз други у пасусу који се
састоји из две колоне; понекад се кôд исписује \color[darkmagenta]{тамно
магента нијансом} којом се у овом документу углавном представљају
\ConTeXt\ команде, а резултат његовог компајлирања у црвеној боји.}}

Приметите како је у првом случају реч \quotation{\TeX} спојена са речи
која јој следи, али у другом случају није. То је зато што је у првом
случају прво \quotation{не-слово} након имена команде \tex{TeX} био
размак, па је потиснут јер \ConTeXt\ претпоставља да се ту налази само
да укаже на крај имена команде, док се у другом случају ту налази
запета, а пошто то није размак, не потискује се.

С друге стране, овај проблем се не решава једноставним уметањем додатног
размака и писањем, на пример,

\color[darkmagenta]{{\tt Познавање \backslash TeX{\ss
{\thinspace\textvisiblespace\thinspace\
\textvisiblespace\thinspace}}помаже да се научи \backslash
ConTeXt}}\footnote{У вези симбола
\quotation{\ss\thinspace\textvisiblespace\thinspace}, присетите се
напомене на \at{страни}[note:invisible space].}.

неће решити проблем, јер \ConTeXt\ правило (које ћемо видети у
\in{одељку}[sec:spaces]) каже да размак апсорбује све празнине и
табулаторе који се налазе иза њега.  Дакле, када имамо овај проблем
(који се на сву срећу не јавља доста често) морамо обезбедити да прво
\quotation{не-слово} након имена команде није размак.  За то постоје два
кандидата:

\startitemize[1]

  \item Резервисани карактери \MyKey{\{\}}. Резервисани карактер
  \MyKey{\{}, као што сам напоменуо, отвара групу, а \MyKey{\}} затвара
  групу, тако да низ \MyKey{\{\}} уводи празну групу. Празна група нема
  ефекта на финални документ, али помаже да \ConTeXt\ зна да име команде
  испред ње завршило.  Или би исто тако могли да креирамо групу око
  команде у питању, на пример тако што напишемо
  \quotation{\{\tex{TeX}\}}.  У сваком случају, резултат ће бити да прво
  \quotation{не-слово} након \tex{TeX} није размак.

  \item Контролни симбол \quotation{\cmd{\textvisiblespace}} (обрнута
  коса црта иза које следи размак, погледајте напомену на
  \at{страни}[note:invisible space]). Овај контролни симбол умеће размак
  у финални документ. Да би се исправно схватила логика система
  \ConTeXt, требало би да се одвоји мало времена и да се види шта се
  дешава када \ConTeXt\ наиђе на контролну реч (на пример \tex{TeX}) иза
  које следи контролни симбол (нпр.
  \quotation{\cmd{\textvisiblespace}}):

  \startitemize[2, packed]

    \item \ConTeXt\ наилази на карактер \backslash\ иза којег следи
    \quote{T} и како зна да ово долази испред контролне речи, он
    наставља са читањем карактера све док не наиђе на
    \quotation{не-слово}, тј. када наиђе на \backslash\ карактер који
    уводи наредни контролни симбол.

    \item Једном када сазна да је име команде \tex{TeX}, покреће команду
    и штампа \TeX\ у финални документ. Затим се враћа на место где је
    прекинуо читање да провери који карактер следи непосредно након
    друге обрнуте косе црте.

    \item Проверава да је то размак, тј. \quotation{не-слово}, што значи
    да је контролни низ тачно то, тако да може да га изврши.  Он то ради
    и умеће размак.

    \item На крају, још једном се враћа на место где је прекинуо читање
    (размак који је био контролни симбол) и наставља да обрађује остатак
    изворног фајла.

  \stopitemize

\stopitemize

Овај механизам сам објаснио детаљније, јер елиминација размака често
изненађује почетнике. Међутим, треба имати на уму да је проблем
релативно мали, јер се контролне речи обично не пишу директно у финални
документ, већ утичу на формати и изглед.  За разлику од тога, прилично
је често да контролни симболи штампају нешто у финални документ.

\startSmallPrint

  Постоји и трећа процедура за спречавање проблема размака, која се
  састоји у дефинисању (у \TeX\ стилу) сличне команде и укључивањем
  \quotation{не-слова} на крај имена команде. На пример, следећи низ:

  \type{\def\txt-{\TeX}}

би креирао команду под именом \tex{txt}, која би радила исто као и
команда \tex{TeX} и функционисала би као треба само ако се позове са
цртицом на крају \tex{txt-}. Технички, ова цртица није део имена
команде, али команда неће радити ако се иза имена не стави цртица.
Разлог зашто је то тако се тиче механизма за дефинисање \TeX\ макроа, а
то је превише компликовано да се овде објасни. Али функционише: када се
ова команда дефинише, сваки пут када употребимо \tex{txt-}, \ConTeXt\ је
замењује са \tex{TeX} тако што елиминише цртицу, али користећи је
интерно да зна да се име команде завршило, тако да се размак непосредно
након команде не брише.

Овај \quote{трик} неће радити како треба са \tex{define} командом,
\ConTeXt\ команда за дефинисање макроа.

\stopSmallPrint

\stopsection

\startsection
  [title=Опсег важења команди]

\startsubsection
  [
    reference=sec:command scope,
    title=Комадне којима треба или не треба назначити опсег важења,
  ]

Многе \ConTeXt\ команде, посебно оне које утичу на форматирање особина
фонтова (црни слог, курзив, капитал, итд.), укључују одређену особину
која остаје активна све док се не наиђе на наредну команду која је
искључује, или која укључује неку другу особину која није компатибилна
са њом. На пример, команда \tex{bf} укључује црни слог, и он остаје
активан све док се не наиђе на {\em некомпатибилну} команду, као што је
\tex{tf}, или \tex{it}.

Пошто нису дизајниране да се примене само на одређени текст, није
потребно да ове врсте команди узимају било какав аргумент. Исто је као
да су ограничене само на {\em укључивање} некакве функције (црни слог,
курзив, безсерифна слова, одређена величина фонта, итд.)

Када се ове команде изврше унутар {\em групе} (погледајте
\in{одељак}[sec:groups]), оне губе свој ефекат када се група у којој се
изврше затвори. Стога, да би ове команде утицале само на одређени део
текста, често се генерише група која садржи команду и текст на који
желимо да она утиче. Група се креира тако што се њен садржај окружи
витичастим заградама. Дакле, следећи текст

\startDoubleExample

\starttyping
У {\it The \TeX Book}, {\sc Кнут}
је објаснио све што треба да знате о
\TeX.
\stoptyping

У {\it The \TeX Book}, {\sc Кнут} је објаснио све што треба да знате о
\TeX.

\stopDoubleExample

креира две групе, једну која одређује опсег важења \tex{it} (курзив)
команде и друге која одређује опсег \tex{sc} (капитал) команде.

За разлику од ове врсте команде, постоје и остале које услед ефекта који
имају, или из неких других разлога захтевају директно навођење текста на
који треба да се примене.  У тим случајевима се текст на који команда
треба да се примени поставља унутар витичастих заграда {\em непосредно
након команде}. Као пример овога би могли да поменемо команду
\tex{framed}: ова команда исцртава оквир око текста који јој се
прослеђује као аргумент, тако да ће 

{\tfx\type{\framed{Татамата и Дедабрада}}}

произвести\blank

\example{\framed{Татамата и Дедабрада}}

Приметите да иако се у првој групи команди (онима које захтевају
аргумент) витичасте заграде понекад користе и за одређивање опсега
дејства, то није неопходно да би команда функционисала. Команда је
дизајнирана тако да се њен ефекат примењује од места на којем се појави.
Зато, када се заградама одређује поље њене примене, команда се поставља
{\em унутар ових заграда}, за разлику од друге групе команди, код којих
заграде које окружују текст над којим треба да се примени команда,
долазе {\em након} команде.

У случају \tex{framed} команде, очигледно је да је за њен ефекат
неопходан аргумент – текст на који треба да се примени. У осталим
случајевима, од програмера зависи да ли је команда једног или другог
типа. Тако, на пример, оно што раде команде \tex{it} и \tex{color} је
прилично слично: оне на текст примењују особину (формат или боју).  Али
донета је одлука да се прва програмира без аргумената, а друга као
команда са аргументом.

\stopsubsection

\startsubsection
  [title=Команде којима је потребно изричито навођење где почињу и где се завршавају (окружења)]

Постоје одређене команде које свој опсег важења одређују прецизним
назначавањем места на којем треба да почну и места на којем њихово
дејство престаје. Тако да ове команде долазе у паровима: једна означава
када се команда укључује, а друга када њено дејство треба да престане.
\quotation{start}, након којег долази име команде се користи да означи
почетак акције, а \quotation{stop}, након којег такође долази име
команде, назначава крај. Тако на пример команда \MyKey{itemize} постаје
\tex{startitemize} и означава почетак {\em набрајања}, а
\tex{stopitemize} означава место где престаје набрајање.

За ове парове команди не постоји посебно име у званичној \ConTeXt\
документацији. Референтно упутство и увод их просто зову
\quotation{start … stop}. Понекад се називају {\em окружења}, што је име
које \LaTeX\ даје сличној врсти конструкција, мада ово има недостатак
јер се у систему \ConTeXt\ израз \quotation{окружење} користи за нешто
сасвим друго (посебну врсту фајла о којем ћемо говорити када у
\in{одељку}[sec-projects] будемо причали о пројектима у више фајлова).
Чак штавише, пошто је израз окружење јасан, а из контекста ће бити лако
да се направи разлика да ли говоримо о {\em командама окружења} или {\em
фајловима окружења}, ја ћу употребљавати овај израз.

Окружења се, дакле, састоје из команде која их отвара или започиње, и
друге које их затвара или завршава. Ако изворни фајл садржи команду за
отварање окружења које се касније не затвара, обично ће се генерисати
грешка.\footnote{Мада не и увек; то зависи од врсте окружења и од
ситуације у остатку документа.  \ConTeXt\ се по овом питању разликује од
система \LaTeX, који је много стриктнији.} С друге стране, ове врсте
грешака се теже проналазе, јер грешка може да се појави много даље
иза места на којем се налази команда отварања.  Понекад ће нам
\MyKey{.log} фајл приказати линију у којој почиње окружење које није
правилно затворено; али у другим приликама ће недостатак затварања
окружења значити да \ConTeXt\ погрешно интерпретира одређени пасаж и не
у том неисправном окружењу, што значи да \MyKey{.log} фајл и није од
неке помоћи у откривању места проблема.

Окружења могу да се угнезде, што значи да друго окружење може да се
отвори унутар постојећег окружења, мада у случајевима када постоје
угњеждена окружења, окружење мора да се затвори унутар окружења у којем
је било отворено. Другим речима, редослед у којем се окружења затварају
мора бити конзистентан са редоследом у којем су била отворена. Верујем
да би ово требало да буде јасно из следећег примера:

{\switchtobodyfont[small]
\startframedtext
\starttyping
\startNesto
  …
  \startNestoDrugo
    …
    \startJosNestoDrugo
      …
    \stopJosNestoDrugo
  \stopNestoDrugo
\stopNesto
\stoptyping
\stopframedtext
}

У примеру можете видети како је окружење \MyKey{JosNestoDrugo} отворено
унутар окружења \MyKey{NestoDrugo}, па мора унутар њега и да се затвори.
Ако се то уради на неки други начин, генерисаће се грешка приликом
компајлирања.

У општем случају, команде дизајниране као {\em окружења} су оне које
имплементирају неку измену која треба да се примени на јединице текста
не мање од пасуса. На пример, окружење \MyKey{narrower} које мења
маргине има смисла само када се примени на нивоу пасуса; или окружење
\MyKey{framedtext} које исцртава оквир око једног или више пасуса.  Ово
последње окружење нам може помоћи да разумемо зашто су неке команде
дизајниране као окружења, а неке као индивидуалне команде: ако желимо да
уоквиримо једну или више речи у једној линији, употребићемо команду
\tex{framed}, али ако желимо да уоквиримо цео пасус (или неколико
пасуса) онда ћемо употребити \MyKey{framedtext} окружење.

С друге стране, текст који се налази унутар одређеног окружења обично
чини {\em групу} (погледајте \in{одељак}[sec:groups]), што значи да ако
се унутар окружења пронађе активациона команда, за разлику од свих
команди које се примењују на сав текст који следи, ова команда ће се
примењивати само до краја окружења у којем се пронађе; а \ConTeXt\
уствари има неименовано {\em окружење} које почиње командом \tex{start}
(без икаквог текста иза; просто {\em start}. Зато га и зовем {\em
неименовано окружење}) и завршава се командом \tex{stop}. Чини ми се да
је једина његова функција да креира групу.

\startSmallPrint

  Нигде у \Conjecture\ConTeXt\ документацији нисам прочитао да је један
  од ефеката окружења да групишу свој садржај, али то је резултат мојих
  тестова са више предефинисаних окружења, мада морам признати да ти
  тестови нису били превише исцрпни.  Просто сам проверио нека насумично
  изабрана окружења. Међутим, моји тестови показују да би таква тврдња,
  у случају да је истинита, важила само за нека предефинисана окружења:
  она креирана командом \tex{definestartstop} (која се објашњава у
  \in{одељку}[sec:startstop]) не креирају било какву групу, осим када
  током дефинисања новог окружења наведемо и команде које су потребне да
  се креира група (погледајте \in{одељак}[sec:groups]).

  Такође је само моја претпоставка да окружења која сам назвао {\em
  неименована} (\tex{start}) окружења постоје само да би се креирала
  група: она креирају групу, али не знам да ли имају још неку другу
  примену.  Ово је једна од недокументованих команди у референтном
  упутству.

\stopSmallPrint

\stopsubsection

\stopsection

\startsection
  [
    title=Опције рада команде,
    reference=sec:command options,
  ]

\startsubsection
  [title=Команде које могу да раде на неколико различитих начина]

Многе команде могу да раде на више од једног начина. У тим случајевима
увек постоји предодређени начин функционисања који се може променити
навођењем параметара који одговарају жељеном начину рада у заградама
након имена команде.

Добар пример овога што сам рекао налазимо у команди \tex{framed}
поменутој у претходном одељку. Ова команда црта оквир око текста који
јој се прослеђује као аргумент. Подразумевано је да оквир има висину и
ширину текста на који се примењује; али можемо да наведемо и неку другу
висину о ширину. Тако да можемо видети разлику између функционисања
подразумеване \tex{framed} команде:

\startDoubleExample

  \type{\framed{Татамата}}

  \framed{Татамата}

\stopDoubleExample

и прилагођене верзије функције:

\startDoubleExample

\starttyping
\framed
  [width=3cm, height=1cm]
  {Татамата}
\stoptyping

\framed
  [width=3cm, height=1cm]
  {Татамата}

\stopDoubleExample

У другом примеру смо унутар великих заграда навели одређену ширину и
висину оквира који окружује текст који команда узима као аргумент.
Унутар заграда се различите конфигурационе опције раздвајају запетама;
размаци па чак и преломи линије (све док нису двоструки прелом линије)
између две или више опција се не узимају у обзир, тако да на пример,
наредне четири верзије команде дају потпуно исти резултат:

{\switchtobodyfont[small]
\startframedtext
\starttyping
\framed[width=3cm,height=1cm]{Татамата}

\framed[width=3cm,    height=1cm]{Татамата}

\framed
  [width=3cm, height=1cm]
  {Татамата}

\framed
  [width=3cm,
    height=1cm]
  {Татамата}

\stoptyping
\stopframedtext
}

Очигледно је да се последња верзија најлакше чита: на први поглед можемо
видети колико има опција и како се користе. У примеру као што је овај,
са само неколико опција, то можда и не изгледа тако важно; али у
случајевима када постоји дугачка листа опција, ако свака од њих заузима
посебну линију у изворном фајлу, лакше ће се {\em разумети} шта изворни
фајл тражи да \ConTeXt\ уради, а такође, ако је то неопходно, лакше ће
се пронаћи и потенцијална грешка. Зато је \quote{пожељно} да корисници
употребљавају овај последњи формат (или неки сличан) писања команди.

Што се тиче синтаксе конфигурационих опција, погледајте даље у тексту
(\in{одељак}[sec:syntax]).

\stopsubsection

\startsubsection
  [title=Команде које конфигуришу начин на који раде друге команде (\cmd{setupNesto})]

Већ смо видели да команде које имају различите начине функционисања
увек поседују подразумевани начин на који раде. Ако се нека од ових
команди позива више пута у изворном фајлу, а желимо да изменимо
подразумевано понашање сваке од њих, уместо да приликом сваког позива
мењамо те опције, много је згодније и ефикасније да се промени
подразумевано подешавање. За то је скоро увек доступна команда чије име
почиње са \tex{setup}, након чега следи име команде чија подразумевана
подешавања желимо да променимо.

Команда \tex{framed} коју смо као пример користили у овом одељку и даље
служи као добар пример. Дакле, ако у свом документу имамо доста оквира,
али сваки од њих захтева прецизне димензије, онда је најбоље да помоћу
\tex{setupframed} реконфигуришемо начин на који функционише команда
\tex{framed}.  Тако ће

{\switchtobodyfont[small]
\starttyping
\setupframed
  [
    width=3cm,
    height=1cm
  ]
\stoptyping
}

обезбедити да од сада сваки позив команде \tex{framed} подразумевано
прави оквир ширине 3 и висине 1 центиметар, без потребе да се то наводи
сваки пут.

Постоји неких 300 \ConTeXt\ команди које нам омогућавају да
конфигуришемо начин функционисања осталих команди. Тако да можемо
конфигурисати подразумевано понашање оквира (\tex{framed}), листи
(\MyKey{itemize}), наслова поглавља (\tex{chapter}), или наслова одељака
(\tex{section}), итд.

\stopsubsection

\startsubsection
  [title=Подешавање прилагођених верзија подесивих команди (\cmd{defineNesto})]

Ако наставимо са \tex{framed} примером, постаје очигледно да ако наш
документ користи неколико врста оквира, сваки са другачијим димензијама,
онда би било идеално када би могли да {\em предефинишемо} различите
конфигурације команде \tex{framed}, па да им придружимо одређено име
којим сваку од њих можемо по потреби да користимо. У систему \ConTeXt\
то можемо да урадимо \tex{defineframed} командом, која има следећу
синтаксу:

\type{\defineframed[Име][Конфигурација]}

где {\em Име} преставља име додељено одређеној врсти оквира који се
конфигурише; а {\em Конфигурација} је одређена конфигурација придружена
том имену.

Ефекат свега овога је да ће се наведена конфигурација придружити имену
које смо јој доделили и које ће се за све намене и сврхе понашати као да
је нека нова команда. Можемо да га користимо у било ком контексту у
којем би могли да користимо и оригиналну команду (\tex{framed}).

Ова могућност не постоји само за овај конкретни случај команде
\tex{framed}, већ и за многе команде које поседују \tex{setup}
могућност. Комбинација \tex{defineNesto} + \tex{setupNesto} је механизам
који систему \ConTeXt\ даје његову екстремну снагу и флексибилност. Ако
детаљно истражимо шта ради команда \tex{defineNesto}, видећемо да:

\startitemize[packed]

  \item Она најпре клонира одређену команду која подржава мноштво
  конфигурација.

  \item Тај клон придружује имену нове команде.

  \item Коначно, поставља предодређену конфигурацију клона која се
  разликује од начина на који је била конфигурисана оригинална команда.

\stopitemize

У примеру који смо навели, конфигурисали смо наш специјални оквир у
време када смо га креирали. Али исто тако прво можемо да га креирамо, па да
га касније конфигуришемо, јер као што сам напоменуо, једном када се
креира клон, он може да се користи свуда где може да се користи и
оригинал. Тако на пример, ако смо креирали оквир под именом
\MyKey{MojSpecijalniOkvir}, можемо да га конфигуришемо командом
\tex{setupframed} уз навођење одређеног оквира који желимо да
конфигуришемо. У овом случају ће \tex{setup} команда да узме нови
аргумент који представља име оквира који се конфигурише:

{\switchtobodyfont[small]
\vbox{\starttyping
\defineframed[MojSpecijalniOkvir]

\setupframed
  [MojSpecijalniOkvir]
  [ ... ]
\stoptyping
}}

\stopsubsection

\stopsection

\startsection
  [
    reference=sec:syntax,
    title={Резиме синтаксе команде и опција, употреба великих и витичастих заграда приликом позивања},
  ]
  % овај одељак је посебно намењен LaTeX корисницима, тако
  % да схвате различиту употребу ових заграда.

Ево резимеа онога што смо видели до сада. У систему \ConTeXt\

\startitemize

  \item Команде у ужем смислу увек почињу карактером
  \quotation{{\tt\backslash}}.

  \item Неке команде могу да узму један или неколико аргумената.

  \item Аргументи који команди говоре {\em како} да функционише или који
  на неки начин утичу на функционисање команде се наводе унутар великих
  заграда.

  \item Аргументи који команди говоре над којим делом текста треба да
  делује се наводе унутар витичастих заграда.

  \startSmallPrint

    Када команда треба да делује само над једним словом, као што је на
    пример то случај са командом \tex{buildtextcedilla} (само као пример
    – \quote{ç} се често користи у каталонском и помало у француском
    језику), витичасте заграде око аргумента могу да се изоставе:
    команда ће се применити на први карактер који није размак.

  \stopSmallPrint

  \item Неки аргументи нису обавезни, па у том случају можемо да их
  изоставимо. Али оно што не можемо никада да променимо јесте редослед
  аргумената који команда очекује.

\stopitemize

Аргументи који се наводе унутар великих заграда могу бити разних врста.
Углавном:

\startitemize

  \item Могу имати само једну вредност која је скоро увек нека реч или
  фраза.

  \item Могу имати разне опције, па у том случају могу:

  \startitemize

    \item Да се представе само једном речи која би могла да буде
    симболичко име (оно чије значење \ConTeXt\ познаје), мера или
    димензија, број, име неке друге команде, итд.

    \item Да се састоје од имена променљивих којима мора бити задата
    вредност. У овом случају нам званична дефиниција команде (погледајте
    \in{одељак}[sec:qrc-setup-en]) увек говори коју врсту вредности
    очекује свака од опција.

    \startitemize

      \item Када је очекивана вредност опције текст, он може да садржи
      размаке, а такође и команде. У тим случајевима је понекад згодно
      да се вредност постави унутар витичастих заграда.

      \item Када је вредност коју очекује опција команда, обично можемо
      да наведемо више команди као ту вредност, мада је понекад потребно
      да све команде које представљају вредност опције поставимо у
      витичасте заграде. Вредност опције такође морамо да поставимо у
      витичасте заграде када било која од команди које су део вредности
      узимају опцију унутар великих заграда.

    \stopitemize

  \stopitemize

  У оба случаја ће различите опције које узима исти аргумент бити
  раздвојене запетама. Размаци и преломи линија (сви осим двоструких
  прелома) између различитих опција се игноришу. Такође се игноришу и
  размаци и преломи линија између различитих аргумената.

  \item Коначно, у систему \ConTeXt\ се никада не догађа да исти
  аргумент истовремено добија опције које са састоје од речи и опције
  које се састоје од променљиве којој се вредност експлицитно додељује.
  Другим речима, можемо имати овакву опцију

  \type{\komanda[Opcija, Opcija2, ...]}

  а неку другу као што је

  \type{\komanda[Promenljiva1=vrednost, Promenljiva2=vrednost, ...]}

  Али никада нећемо наићи на мешавину обе:

  \type{\komanda[Opcija1, Promenljiva1=vrednost, ...]}

\stopitemize

\stopsection

\startsection
  [
    title=Званична листа \ConTeXt\ команди,
    bookmark=Званична листа ConTeXt команди,
    reference=sec:qrc-setup-en
  ]
  % Овај одељак је написан само да би се указало на њега сваки пут
  % када се помене „званична листа” команди.

У \ConTeXt\ документацији постоји један посебно важан документ који
приказује листу свих команди и за сваку од њих наводи колико аргумената
које врсте очекује, као и различите осмишљене опције и њихове дозвољене
вредности.  Овај документ се назива \MyKey{setup|-|en.pdf} и аутоматски
се генерише за сваку нову верзију система \ConTeXt. Можете га пронаћи у
директоријуму
\MyKey{tex/texmf|-|context/doc/context/documents/general/qrcs}.

\startSmallPrint

  Уствари постоји седам верзија \MyKey{qrc} документа, по једна за сваки
  од језика који имају \ConTeXt\ интерфејс: немачки, чешки, француски,
  холандски, енглески, италијански и румунски. За сваки од ових језика у
  директоријуму постоје два документа: један се назива
  \MyKey{setup-КодЈезика} (где је КодЈезика двословни међународни
  идентификатор језика), а други се зове
  \MyKey{setup-mapping-КодЈезика}.  Овај други документ садржи листу
  команди у абецедном редоследу која наводи {\em прототип} команде, али
  без даљих информација омогућим вредностима за сваки аргумент.

\stopSmallPrint

Овај документ је од изузетног значаја за учење употребе система
\ConTeXt, јер у њему можемо да пронађемо да ли одређена команда постоји
или не; ово је заиста корисно, имајући у виду комбинацију {\sc команда}
(или {\sc окружење}) + {setup{\sc команда} + define{\sc команда}.  На
пример, ако знам да се празна линија уноси командом \tex{blank}, могу да
пронађем да ли постоји команда под називом \tex{setupblank} која ми
омогућава да је конфигуришем, и друга која ми дозвољава да подезим
прилагођену конфигурацију за празне линије, (\tex{defineblank}).

\startSmallPrint

  \MyKey{setup-en.pdf} је дакле, незаменљив код учења система \ConTeXt.
  Али ја бих заиста више волео да нам он првенствено каже да ли команда
  ради само у верзији Mark~II или Mark~IV, а посебно да нам уместо
  набрајања типова аргумената које узима свака команда каже чему служе ти
  аргументи.  То би у знатној мери умањило недостатке \ConTeXt\
  документације. Неке команде дозвољавају и необавезне аргументе које у
  овом уводу чак ни не помињем јер не знам чему служе, а пошто нису
  обавезни нема било какве потребе да их помињем. Ово заиста изазива
  огромну фрустрацију.

\stopSmallPrint

\stopsection

\startsection
  [
    reference=sec:definingcommands,
    title=Дефинисање нових команди,
  ]

\startsubsection
  [
    reference=sec:define,
    title=Општи меанизам за дефинисање нових команди,
  ]
\PlaceMacro{define}

Управо смо видели како помоћу \tex{defineNesto} можемо да клонирамо
постојећу команду и развијемо њену нову верзију, која ће за све намене и
сврхе функционисати као нова команда.

Уз ову могућност, која је доступна само за неке одређене команде
(сигурно поприличан број њих, али не све), \ConTeXt\ поседује општи
механизам за дефинисање нових команди који је изузетно моћан, мада је у
одређеним применама и прилично сложен. У тексту као што је овај,
намењеном почетницима, мислим да је најбоље да се уведе тако што се
почне од неких његових најједноставнијих употреба.  Најједноставнија од
свих је да се фрагменти текста придруже некој речи, па сваки пут када се
та реч појави у изворном фајлу, она се замени са текстом повезаним са
њом. С једне стране, ово ће нам омогућити да уштедимо доста времена за
куцање, а с друге стране, додатна предност је што се умањује могућност
грешака у куцању, а у исто време се обезбеђује да је тај текст увек
исписан на исти начин.

Хајде да замислимо, на пример, да пишемо трактат о алитерацији у
латинским текстовима, у којем често цитирамо латинску реченицу
\quotation{{\em O Tite tute Tati tibi tanta tyranne tulisti}} (О Тите
Татијусе, ти тиранине, толико тога си навукао на себе!).  То је прилично
дугачка реченица у којој су две речи личне именице које почињу великим
словом и где је, морамо признати, колико год да волимо латинску поезију,
лако да се „саплетемо” када је пишемо. У овом случају, могли бисмо да у
преамбулу изворног фајла једноставно ставимо следеће:

{\tfx \type{\define\Tite{\quotation{O Tite tute Tati tibi tanta tyranne tulisti}}}}

Према оваквој дефиницији, сваки пут када се команда \tex{Tite} појави у
нашем изворном фајлу, она ће се заменити за наведеном реченицом, а
налазиће се и унутар знака навода као што их је имала и оригинална
дефиниција, чиме смо обезбедили да ће реченица сваки пут имати исти
изглед.  Могли смо и да је испишемо курзивом, већом величином фонта…
како год желимо.  Битна ствар је што је потребно да је испишемо само
једном, а кроз цео текст ће се исписивати на потпуно исти начин на који
смо је написали, без обзира на то колико често се понавља. Такође бисмо
могли да креирамо две верзије команде под називом \tex{Tite} и
\tex{tite}, у зависности од тога да ли је потребно да се реченица испише
великим словима или не.  Текст замене може бити чист текст, а може да
садржи и команде, или да формира математичке изразе у којима је (барем у
мом случају) већа вероватноћа да дође до грешке у куцању. На пример, ако
је потребно да се израз $(x_1,\ldots\thinspace,x_n)$ често појављује у
нашем тексту, могли би да креирамо команду која га представља. На пример

{\tfx\type{\define\xvec{$(x_1,\ldots\thinspace,x_n)$}}}

тако да кад год се у тексту појави \tex{xvec}, замениће се са изразом
који је придружен тој команди.

У општем случају, синтакса \tex{define} команде је:

\type{\define[БрАргумената]\ИмеКоманде{ТекстЗаЗамену}}

% {\ttx \color[maincolor]{\backslash define[{\em
%         NumArguments}]\backslash {\em CommandName}\{{\em
%       TextoReplace}\}}}

где се

\startitemize[packed]

  \item {\tt\bf БрАргумената} односи на број аргумената које узима нова
  команда. Ако не узима ниједан, као у претходним примерима, ово може и
  да се изостави.

  \item {\tt\bf ИмеКоманде} односи на име које се даје новој команди.
  Овде важи опште правило које се тиче имена команди. Име би могло да
  буде и један карактер који није слово, или једно или више слова без
  употребе било каквог \quotation{не-слово} карактера.

  \item {\tt\bf ТекстЗаЗамену} састоји из текста који ће да замени име
  нове команде, сваки пут када се она појави у изворном фајлу.

\stopitemize

Могућност дефинисања нових команди са аргументима у дефиницији даје
механизму велику флексибилност, јер омогућава да се дефинише променљиви
текст замене који ће одредити прослеђени аргументи.

На пример: замислимо да желимо написати команду која креира почетак
пословног писма. Врло проста верзија тога би била:

{\switchtobodyfont[small]
\starttyping
\define\ZaglavljePisma{
  \rightaligned{Петар Петровић}\par
  \rightaligned{Консултант}\par
  Зајечар, \date\par
  Драги господине,\par
  }
\stoptyping
}

али би било добро да имамо верзију команде која би у заглављу исписала
име примаоца. То би захтевало да употребимо параметар који новој команди
преноси име примаоца писма. Команда би требало да се редефинише на
следећи начин:

{\switchtobodyfont[small]
\starttyping
\define[1]\ZaglavljePisma{
  \rightaligned{Петар Петровић}\par
  \rightaligned{Консултант}\par
  Зајечар, \date\par
  Драги г. #1,\par
  }
\stoptyping
}

Приметите да смо у дефиницију унели две измене. Прво смо између кључне
речи \tex{define} и новог имена команде, уметнули 1 у велике заграде
([1]). То систему \ConTeXt\ говори да команда коју дефинишемо узима
један аргумент. Даље, у последњој линији дефиниције команде, написали
смо \quotation{{\tt Драги г. \#1,}}, користећи резервисани карактер
\MyKey{\#}. То наводи да се у тексту замене на месту појављивања
\MyKey{\#1} умеће садржај првог аргумента. Да је било два параметра,
\MyKey{\#1} би се односило на први параметар, а \MyKey{\#2} на други. Да
би се (у изворном фајлу) позвала команда, након имена команде морају да
се у витичастим заградама наведу аргументи, сваки у свом пару заграда.
Тако да би команда коју смо управо дефинисали, требало да се у тексту
изворног фајла позива на следећи начин:

\type{\ZaglavljePisma{Име примаоца}}

% {\ttx \color[maincolor]{\backslash LetterHeading\{{\em Addressee
% name}\} }}

На пример: \cmd{ZaglavljePisma\{Марко Марковић\}}.

Претходну функцију би још могли да унапредимо, јер претпоставља да ће се
писмо слати мушкарцу (поставља \quotation{Драги господине}}), тако да би
требало да се наведе још један параметар којим се прави разлика између
мушког и женског примаоца. На пример:

{\switchtobodyfont[small]
\starttyping
\define[2]\ZaglavljePisma{
  \rightaligned{Петар Петровић}\par
  \rightaligned{Консултант}\par
  Зајечар, \date\par
  #1\ #2,\par
  }
\stoptyping
}

тако да би функција могла да се позове, на пример, са

{\tfx\type{\ZaglavljePisma{Драга г.}{Марија Марјановић}}}

мада ово и није баш елегантно (са програмерске тачке гледишта). Боље би
било да се симболичке вредности дефинишу као први аргумент
(мушкарац/жена; 0/1; м/ж) тако да сам макро према тој вредности изабере
одговарајући текст.  Али да бисмо објаснили како се то постиже, потребно
је да уђемо дубље у материју коју сматрам да читалац-почетник у овом
тренутку не може да разуме.

\stopsubsection

\startsubsection
  [
    reference=sec:startstop,
    title=Креирање нових окружења,
  ]

\PlaceMacro{definestartstop}

За креирање новог окружења, \ConTeXt\ обезбеђује \tex{definestartstop}
команду која има следећу синтаксу:

\type{\definestartstop[Име][Опције]}

% {\ttx \color[maincolor]{\backslash definestartstop[{\em Name}][{\em
% Options}]}}

\startSmallPrint

  У {\em званичној} \tex{definestartstop} дефиницији (погледајте
  \in{одељак}[sec:qrc-setup-en]) постоји додатни аргумент који овде
  нисам навео, и за који нисам успео да пронађем \Doubt чему служи.  Не
  објашњавају га ни уводни \ConTeXt\ \quotation{Excursion}, ни
  недовршено референтно упутство.  Претпоставио сам да би овај аргумент
  (који мора да се унесе између имена и конфигурације) могао да буде име
  неког постојећег окружења које би послужило као почетни модел за ново
  окружење, али моји тестови показују да је та претпоставка погрешна.
  Претражио сам \ConTeXt\ мејлинг листу и нисам наишао на било какву
  употребу овог могућег аргумента.

\stopSmallPrint

где

\startitemize

  \item {\bf Име} представља име које ће добити ново окружење.

  \item {\bf Конфигурација} омогућава да конфигуришемо понашање новог
  окружења. Имамо на располагању следеће вредности којима можемо да га
  подесимо:

  \startitemize

    \item {\tt before} – Команде које треба да се изврше пре уласка у
    окружење.

    \item {\tt after} – Команде које треба да се изврше након напуштања
    окружења.

    \item {\tt style} – Стил који мора да има текст новог окружења.

    \item {\tt setups} – Скуп команди креиран са
      \PlaceMacro{startsetups}\tex{startsetups ... \stopsetups}. Овај
      увод не објашњава ову команду и њену употребу.

    \item {\tt color, inbetween, left, right} – Недокументоване опције
    које нисам успео да употребим. Из њиховог имена можемо претпоставити
    \Doubt шта неке од њих раде, на пример {\tt color}, али из више тестова
    које сам извршио, дајући неку вредност тој опцији, нисам видео било
    какву промену унутар окружења.

  \stopitemize

\stopitemize

Ево примера могуће дефиниције окружења:

{\switchtobodyfont[small]
\starttyping
\definestartstop
  [TextWithBar]
  [before=\startmarginrule\noindentation,
    after=\stopmarginrule,
    style=\ss\sl
  ]

\starttext

Прва два основна закона људске глупости недвосмислено тврде да:

\startTextWithBar

  \startitemize[n,broad]

    \item Увек и неизбежно потцењујемо број глупих индивидуа на свету.

    \item Вероватноћа да је дата особа глупа не зависи од било које
    друге карактеристике те исте особе.

  \stopitemize

\stopTextWithBar

\stoptext
\stoptyping
}

Резултат би био:

\definestartstop
  [TextWithBar]
  [before=\startmarginrule\noindentation,
    after=\stopmarginrule,
    style=\ss\sl,
  ]

\startframedtext[frame=off]

  \color[red]{Прва два основна закона људске глупости недвосмислено
  тврде да:

\startTextWithBar

  \startitemize[n,broad]

    \item Увек и неизбежно потцењујемо број глупих индивидуа на свету.

    \item Вероватноћа да је дата особа глупа не зависи од било које
    друге карактеристике те исте особе.

\stopitemize

\stopTextWithBar}
\stopframedtext

Ако желимо да наше ново окружење буде група (\in{одељак}[sec:groups]),
тако да било каква измена уобичајеног начина функционисања система
\ConTeXt\ која се деси унутар окружења престане чим се напусти
окружење, морамо да укључимо команду \PlaceMacro{bgroup}\tex{bgroup} у
опцију \MyKey{before} и команду \PlaceMacro{egroup}\tex{egroup} у опцију
\MyKey{after}.

\stopsubsection

\stopsection

\startsection
  [title=Остали основни концепти]

Осим команди, постоје и други појмови који су фундаментални за
разумевање логике која одређује функционисање система \ConTeXt. Због
своје сложености, неки од њих нису погодни за увод, па у овом документу
о њима нећемо говорити; али постоје два појма која би сада требало да
испитамо: групе и димензије.

\startsubsection
  [reference=sec:groups, title=Групе]

Група је добро дефинисан фрагмент изворног фајла који \ConTeXt\ користи
као {\em радну јединицу} (ускоро ћу објаснити шта то значи).  Свака
група има почетак и крај који експлицитно морају да се назначе.  Група
почиње:

\startitemize[packed]

  \item Резервисаним карактером \MyKey{\{} или командом
    \PlaceMacro{bgroup}\tex{bgroup}.

  \item Командом \PlaceMacro{begingroup}\tex{begingroup}

  \item Командом \PlaceMacro{start}\tex{start}

  \item Отварањем одређених окружења (командом \tex{startNesto}).

  \item Отварањем математичког окружења (резервисаним карактером
  „\$”).

\stopitemize

а затвара се

\startitemize[packed]

  \item Резервисаним карактером \MyKey{\}} или командом
    \PlaceMacro{egroup}\tex{egroup}.

  \item Командом \PlaceMacro{endgroup}\tex{endgroup}

  \item Командом \PlaceMacro{stop}\tex{stop}

  \item Затварањем окружења (командом \tex{stopNesto}).

  \item Напуштањем математичког окружења (резервисаним карактером
    „\$”).

\stopitemize

Одређене команде такође аутоматски генеришу групу, на пример,
\tex{hbox}, \tex{vbox} и, у општем случају, команде повезане са
креирањем {\em кутија}\footnote{Појам {\em кутија} је такође основни
\ConTeXt\ појам, али се његово објашњење не даје у овом уводу.}. Осим
ових последњих случајева (групе које одређене команде аутоматски
генеришу), начин затварања групе мора бити конзистентан са начином на
који је отворена. Ово значи да група која је започета са \MyKey{\{} мора
да се затвори са \MyKey{\}}, а група започета са \tex{begingroup} мора
да се затвори са \tex{endgroup}. Ово правило има само један изузетак, да
група започета са \MyKey{\{} може да се затвори са \tex{egroup}, а да
група започета са \tex{bgroup} може да се затвори са \MyKey{\}}; то у
суштини значи да су \MyKey{\{} и \tex{bgroup} потпуно идентични и могу
да се користе једно уместо другог, а слично је и са \MyKey{\}} и
\tex{egroup}.

\startSmallPrint

  Команде \PlaceMacro{bgroup}\tex{bgroup} и
  \PlaceMacro{egroup}\tex{egroup} су дизајниране да би били у могућности
  да отворимо и затворимо групу. Стога, из разлога који се тичу \TeX\
  синтаксе, те групе нису могле да отворе и затворе витичастим заградама,
  јер би се тако у изворном фајлу генерисале неупарене витичасте заграде,
  а то би увек изазивало грешку током компајлирања.

  За разлику од њих, команде \PlaceMacro{begingroup}\tex{begingroup} и
  \PlaceMacro{endgroup}\tex{endgroup} не могу да се користе уместо
  витичастих заграда или \tex{bgroup  ... \egroup} команди јер група која
  је започета са \tex{begingroup} мора да се затвори са \tex{endgroup}.
  Ове друге команде су дизајниране тако да се омогући детаљнија провера
  грешака. У општем случају, обични корисници немају потребу да их
  користе.

\stopSmallPrint

Можемо имати угњеждене групе (групу унутар друге групе), па у том
случају редослед у којем се групе затварају мора бити конзистентан са
редоследом у којем су биле отворене: било која подгрупа мора да се
затвори унутар групе у којој је била отворена. Такође могу да постоје и
празне групе, генерисане са \MyKey{\{\}}. У принципу, празна група нема
утицаја на финални документ, али може бити корисна, на пример, да се
назначи крај имена команде.

Главна намена група је да обухвате свој садржај у једну целину:
дефиниције, формати и доделе вредности које се ураде унутар групе се по
правилу \quotation{заборављају} чим напустимо групу.  Дакле, ако желимо
да \ConTeXt\ привремено измени свој уобичајени начин функционисања,
најбољи начин да то постигнемо је да креирамо групу, па да унутар ње
изменимо то функционисање.  Затим, када напустимо групу, све вредности и
формати који су важили пре ње ће се вратити. Већ смо видели неке примере
овога када смо поменули команде као што су \tex{it}, \tex{bf}, \tex{sc},
итд. Али ово се не дешава само са командама форматирања: група на неки
начин {\em изолује} свој садржај, тако да било каква измена било које од
многих интерних променљивих којима \ConTeXt\ константно управља важи
само док се налазимо унутар групе у којој је промена направљена. Слично,
команда дефинисана унутар групе не постоји ван ње.

Тако да ако обрадимо следећи пример

\starttyping
\define\A{B}
\A
{
  \define\A{C}
  \A
}
\A
\stoptyping

видећемо да када се први пут изврши команда \tex{A}, резултат одговара
њеној почетној дефиницији (\quote{B}). Затим смо креирали групу и у њој
редефинисали команду \tex{A}. Ако је сада извршимо унутар групе, команда
ће нам вратити нову дефиницију (\quote{C} у нашем примеру), али када
напустимо групу у којој је команда \tex{A} била редефинисана и извршимо
је још једном, она ће поново да испише \quote{B}. Дефиниција направљена
унутар групе се \quotation{заборавља} чим напустимо ту групу.

Још једна могућа употреба група се тиче команди или инструкција
дефинисаних да се примене само на карактер написан иза њих. У овом
случају, ако желимо да се команда примени на више карактера, морамо да
их поставимо унутар групе. Тако на пример, резервисани карактер
\MyKey{\letterhat} који, као што већ знамо, конвертује наредни карактер
у експонент када се користи унутар математичког окружења; па ако на
пример напишемо \MyKey{\$4^2x\$} добићемо \quotation{$4^2x$ }. Али ако
напишемо \MyKey{\$4^\{2x\}\$} добићемо \quotation{$4^{2x}$}.

Коначно, трећа употреба груписања је да се систему \ConTeXt\ каже да оно
што се налази унутар групе третира као целину. То је разлог што је
раније у (\in{одељку}[sec:syntax]) речено да је у неким ситуацијама боље
да се садржај неке опције команде стави унутар витичастих заграда.

\stopsubsection

\startsubsection
  [reference=sec:dimensions, title=Димензије]

Мада би систем \ConTeXt\ могли савршено добро да користимо без бриге о
димензијама, не бисмо могли да искористимо све могућности подешавања ако
се не упознамо са њима. Јер типографска перфекција система \TeX\ и оних
изведених из њега у великој мери зависи од тога што систем интерно води
рачуна о димензијама.  Карактери имају димензије; размак између речи,
или између линија, или између пасуса има димензије; линије имају
димензије; маргине, заглавља и подножја. Постојаће димензија за скоро
сваки елемент стране који може да нам падне на памет.

Димензије се у систему \ConTeXt\ наводе децималним бројем иза кога следи
јединица мере. У \in{табели}[tbl:measurements] су наведене јединице које
могу да се употребе.

\placetable
  [here]
  [tbl:measurements]
  {Јединице мере у систему \ConTeXt}
{\starttabulate[|l|c|l|]
  \NC {\bf Име} \NC {\bf Име у \ConTeXt}\NC {\bf Еквивалент}\NR
\NC Инч\NC in\NC 1 in $=$ 2.54 cm\NR
\NC Центиметар\NC cm\NC 2.54 cm $=$ 1 инч\NR
\NC Милиметар\NC mm\NC 100 mm $=$ 1 cm\NR
\NC Тачка\NC pt\NC 72.27 pt $=$ 1 инч\NR
\NC Велика тачка\NC bp\NC 72 bp $=$ 1 инч\NR
\NC Скалирана тачка\NC sp\NC 65536 sp $=$ тачка\NR
\NC Пика\NC pc\NC 1 pc $=$ 12 тачака\NR
\NC Дидо\NC dd\NC 1157 dd $=$ 1238 тачака\NR
\NC Цицеро\NC cc\NC 1 cc $=$ 12 дидоа\NR
\NC\NC em\NR
\NC\NC ex\NR
\stoptabulate
}

Прве три јединице у \in{табели}[tbl:measurements] су стандардне јединице
за дужину; прва се користи у неким деловима света енглеског говорног
подручја, а остале ван њега или у неким његовим деловима.  Остале
јединице долазе из света типографије. Последње две, за које нисам навео
еквивалент, су релативне јединице мере чија је основа текући фонт.  1
\quotation{em} представља ширину карактера \quotation{M}, а
\quotation{ex} представља ширину карактера \quotation{x}. Употреба мера
везаних за величину фонта омогућава креирање макроа који изгледају
једнако добро без обзира на то који извор се користи у датом тренутку.
Зато се у општем случају и препоручује њихова употреба.

Уз неколико изузетака, можемо да користимо било коју јединицу мере која
нам одговара, јер ће \ConTeXt\ интерно да их конвертује. Али увек када
се наведе димензија, обавезно је да се наведе и јединица мере, па чак и
ако желимо да задамо меру \quotation{0}, морамо да напишемо \quote{0pt}
или \quote{0cm}. Између броја и имена јединице можемо, али не морамо да
уметнемо размак. Ако јединица има децимални део, можемо да употребимо
децимални граничник, или (.) или запету (,).

Мере се обично користе као опција неке команде. Али можемо и директно да
доделимо вредност некој интерној мери система \ConTeXt\ само је потребно
да знамо њено име. На пример, увлачење прве линије пасуса се у систему
\ConTeXt\ интерно контролише променљивом која се назива
\PlaceMacro{parindent}\tex{parindent}. Ако јој експлицитно наведемо
вредност, променићемо од тада па надаље меру коју користи \ConTeXt. Па
тако, ако желимо да елиминишемо увлачење прве линије, потребно је само
да у изворном фајлу напишемо:

\type{\parindent=0pt}

Такође смо могли да напишемо и \tex{parindent 0pt} (без знака једнакости)
или \tex{parindent0pt} без размака између имена јединице и вредности.

Међутим, сматра се да директна додела интерној мери \quotation{није
елегантна}. У општем случају, препоручује се да се употребе команде које
контролишу ту променљиву, и да се то уради у преамбули изворног фајла.
Ако се тако не уради, добија се изворни фајл у којем се грешке врло
тешко отклањају јер се све конфигурационе команде не налазе на истом
месту, па је заиста тешко да се достигне одређена конзистентност
типографских карактеристика.

Неке од димензија које користи \ConTeXt\ су \quotation{еластичне}, то
јест, у зависности од контекста, оне имају једну или другу вредност.
Ове мере се наводе следећом синтаксом:

\type{\ИмеМере plus МаксУвећање minus МаксУмањење}

% {\tt\backslash {\em MeasureName} plus {\em MaxIncrement} minus
%   {\em MinDecrease}}

На пример

\type{\parskip 3pt plus 2pt minus 1pt}

Ова инструкција систему \ConTeXt\ говори да димензији
\PlaceMacro{parskip}\tex{parskip} (која задаје вертикални размак између
пасуса) {\em нормалну} меру од 3 тачке, али тако да ако композиција
странице то захтева, мера може да буде до 5 тачака (3 плус 2) или само 2
тачке (3 минус 1).  У овим случајевима ће \ConTeXt\ изабрати размак за
сваку страницу између минимално 2 тачке и максимално 5 тачака.

\stopsubsection

\stopsection

\startsection
  [title=Метода за самостално учење система \ConTeXt,
  bookmark=Метода за самостално учење система ConTeXt]

  % Одељак који је додат у последњем тренутку, када сам схватио да сам
  % постао толико прожет духом система ConTeXt и постао способан да
  % погодим постојање одређених команди.

Испоставља се да је огромна количина \ConTeXt\ команди и опција заиста
поражавајућа и може да нам остави утисак да никада нећемо успети да
радимо у њему на одговарајући начин. Овај утисак може да завара, јер је
једна од предности система \ConTeXt\ уједначен начин на који ради са
свим својим структурама: ако добро научимо неколико структура, и ако,
мање више знамо чему служе остале, биће нам релативно лако да научимо
како се користе када нам буде била потребна нека додатна могућност.
Стога овај увод посматрам као неку врсту {\em обуке} која ће да нас
приреми за своја сопствена истраживања.

Да бисте креирали документ системом \ConTeXt, вероватно је неопходно да
познајете само следећих пет основних ствари (могли бисмо их назвати
\ConTeXt\ {\em Топ 5}):

\startitemize[n]

  \item Како да креирате изворни фајл или пројекат; ово се објашњава у
  \in{поглављу}[cap:sourcefile] овог увода.

  \item Поставите главни фонт документа и знате основне команде за
  промену фонта и боја (\in{поглавље}[sec:fontscol]).

  \item Основне команде за креирање структуре садржаја документа, као
  што су поглавља, одељци, пододељци, итд. Све ово је објашњено у
  \in{поглављу}[cap:structure].

  \item Можда и како да управљате окружењем {\em набрајања}, што је
  детаљно описано у \in{одељку}[sec:itemize].

  \item … још понешто.

\stopitemize

Што се тиче осталог, све што је потребно да знате је да је то уопште
могуће. Сигурно је да нико неће користити могућност ако не зна да она
уопште и постоји.  Многе од њих су описане у овом уводу; али
првенствено, увек можемо да посматрамо како се систем \ConTeXt\ 
понаша када наиђе на одређену врсту конструкције:

\startitemize

  \item Прво ће постојати команда која имплементира могућност.

  \item Друго, скоро увек и команда која нам омогућава да конфигуришемо
  и унапред одредимо како ће се задатак извршити; команда чије име почиње
  са \tex{setup} и која се обично подудара са основном командом.

  \item Коначно, обично је могуће да се креира нова команда која обавља
  сличне задатке, али са другачијом конфигурацијом.

\stopitemize

Ако желите сазнати да ли ове команде постоје или не, претражите званичну
листу команди (погледајте \in{одељак}[sec:qrc-setup-en]), која ће вас
такође упознати са конфигурационим опцијама које могу да се користе са
командама.  И мада на први поглед имена ових команди могу изгледати {\em
неразумљиво}, убрзо ћемо видети да постоје опције које се понављају у
многим командама и које у свим тим командама раде на исти или врло
сличан начин.  Ако нисмо сигурни у то шта нека опција ради, или како
ради, биће довољно да креирамо документ и тестирамо је. Такође можемо да
погледамо у обимну \ConTeXt\ документацију. Као што је уобичајено у
свету слободног софтвера, \suite- садржи изворне фајлове скоро комплетне
документације у дистрибуцији.  Када желимо да знамо да ли се опција која
нас интересује употребљава у било ком од ових изворних фајлова, алат као
што је \MyKey{grep} (за GNU Linux системе) нам може помоћи да их све
претражимо и видимо на конкретном примеру како се опција користи и шта
ради.

Ово је начин на који је замишљено учење система \ConTeXt: увод детаљно
објашњава пет (тачније четири) аспекта које сам истакао, и још више: док
читамо, у глави ћемо формирати јасну слику редоследа: {\em команда која
извршава задатак} – {\em команда која конфигурише претходну} – {\em
команда која омогућава креирање сличне команде}. Такође ћемо научити и
неке од основних структура система \ConTeXt\ и знаћемо за шта се оне
користе.

\stopsection

\stopchapter

\stopcomponent

%%% Local Variables:
%%% mode: ConTeXt
%%% mode: auto-fill
%%% TeX-master: "../introCTX.mkiv"
%%% coding: utf-8-unix
%%% End:
%%% vim:set filetype=context tw=72 : %%%
