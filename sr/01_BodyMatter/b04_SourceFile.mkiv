%%% Фајл:     b04_SourceFile.mkiv
%%% Аутор:    Joaquín Ataz-López
%%% Започето: Април 2020
%%% Завршено: Јун 2020
%%% Садржај:  Идеја за први део овог поглавља је дошла из поглавља 2
%%%	      књиге The TeX Book: "Штампање књиге у односу на обично куцање". У
%%%	      суштини, ту се објашњава како се пише изворни фајл. У почетку је
%%%	      ово поглавље садржало и део онога што је на крају постало
%%%	      поглавље 10 и додатак Б. Али сам у последњем тренутку одлучио да
%%%	      га прерадим и повежем са радом на пројектима који сам у почетку
%%%	      планирао да се налази на крају. Мислим да је овај последњи
%%%	      редослед пожељнији.
%%%   
%%% Уређивано са: Emacs + AuTeX - и повремено са vim + context-plugin
%%%

% \environment ../introCTX_env.mkiv

\startcomponent b04_SourceFile.mkiv

\startchapter
  [reference=cap:sourcefile, title=Изворни фајлови и пројекти]

\TocChap

Као што већ знамо, када радимо у систему \ConTeXt\ увек почињемо текст фајлом у
којем се, уз садржај финалног документа, налази и већи број инструкција које
наводе трансформације помоћу којих \ConTeXt\ из изворног фајла генерише
коректно форматирани излазни документ у PDF формату.

Имајући у виду читаоце који су до сада познавали само рад у текст процесорима,
мислим да вреди уложити нешто времена у сам изворни фајл.  Или пре, изворне
фајлове, јер понекада постоји само један изворни фајл, а некада користимо већи
број изворних фајлова да дођемо до финалног документа.  У овом последњем
случају говоримо о \quotation{пројектима са више фајлова}.

\startsection
  [title=Кодирање изворних фајлова, reference=sec:encoding]

Изворни фајл(ови) мора(ју) бити текст фајл(ови). У компјутерској терминологији,
овако се назива фајл који садржи само читљиви текст и који не садржи никакав
бинарни кôд.  Ови фајлови се такође називају и {\em прости текст} или {\em
чисти текст} фајлови.

Пошто компјутерски системи интерно обрађују само бинарне бројеве, текст фајл се
уствари састоји од {\em бројева} који представљају {\em карактере}.  За
повезивање броја са карактером се користи {\em табела}. За текст фајлове
постоји више могућих табела. Израз {\em кодирање текст фајла} се односи на
одређену табелу мапирања карактера коју користи дати текст фајл.

\startSmallPrint

  Постојање различитих табела кодирања текст фајлова је последица саме историје
  компјутерске науке. У раним фазама развоја, када је капацитет меморије и
  складишта компјутерских уређаја био скроман, одлучено је да се користи табела
  под именом ASCII (што је акроним од \quotation{{\em American Standard Code
  for Information Interchange}}) која је дозвољавала само 128 карактера и
  успоставио ју је Амерички комитет за стандарде 1963. године.  Очигледно је да
  128 карактера није довољно да се представе сви карактери и симболи који се
  користе у свим светским језицима; али је било више него довољно да се
  представи енглески језик који, од свих западних језика има најмање карактера,
  јер не употребљава дијакритике (акценте и остале знаке изнад, испод, или кроз
  остала слова). Предност употребе ASCII табеле је што текст фајлови заузимају
  врло мало простора, јер 127 (највећи број у табели) може да се представи са
  бинарним бројем од 7 цифара, а први компјутери су користили бајт за мерење
  меморије, односно бинарни број са 8 цифара. Било који карактер у табели је
  могао да се смести у један бајт. Пошто бајт има 8 цифара, а ASCII користи
  само 7, чак је остало простора да се додају у неки други карактери којима
  могу да се представе остали језици.

  Али када се употреба компјутера проширила, постало је очигледно да ASCII није
  адекватан, па је дошло до развоја {\em алтернативних} табела у којима су се
  налазили карактери ван енглеског алфабета, као што је шпанско \quote{ñ},
  акцентовани самогласници, каталонско или француско \quote{ç}, итд. С друге
  стране, није било почетног договора како би те ASCII {\em алтернативне
  табеле} требало да изгледају, тако да су различите специјализоване
  компјутерске компаније постепено саме решавале проблем. Из тог разлога, не
  само да су развијене одређене табеле за различите језике или групе језика,
  већ и различите табеле према компанији која их је креирала (Microsoft, Apple,
  IBM, итд.).

  Идеја да се креира једна табела која би обухватила све језике се појавила тек
  са повећањем компјутерске меморије и смањењем цене уређаја за складиштење.
  Али да истакнемо, уствари се није креирала једна табела која садржи све
  карактере, већ стандардно кодирање (под називом {\sc Уникод}) уз различите
  начине за његово представљање (UTF-8, UTF-16, UTF-32, итд.) Од свих ових
  система, UTF-8 је на крају постао {\em де факто} стандард којим може да се
  представи практично било који живи језик, као и многи већ изумрли језици и
  бројни додатни симболи. Сви они користе бројеве променљиве дужине (између 1 и
  4 бајтова), што у суштини помаже да се оптимизује величина текст фајлова. Ова
  величина се није {\em значајно} увећала у односу на текст фајлове који
  користе чисти ASCII.

  Све док се није појавио \XeTeX, системи засновани на \TeX\ – који су такође
  рођени у САД, па су зато користили енглески као свој природни језик –
  претпостављали су да је кодирање чисти ASCII; а ако сте желели да користите
  неко друго кодирање, морали сте на неки начин да га наведете у изворном
  фајлу.

\stopSmallPrint

\dontleavehmode\ConTeXt\ Mark~IV претпоставља да је кодирање UTF-8.  Ипак,
на мало старијим компјутерским системима се можда још увек као
подразумевано кодирање користи неко друго. Нисам потпуно сигуран које
подразумевано кодирање користи Windows, када се има у виду стратегија
компаније Microsoft да скривањем сложености дође до шире публике (али мада
је скривена, то не значи да је елиминисана!). Нема много доступних
информација (или можда ја нисам успео да их пронађем) у вези са системом
кодирања који подразумевано користи.

У сваком случају, које год да је подразумевано кодирање, сваки текст едитор
вам омогућава да фајл сачувате у жељеном кодирању. Изворни фајлови које
треба да обради \ConTeXt\ Mark IV морају да се сачувају у UTF-8, осим,
наравно, када постоји веома добар разлог да се употреби неко друго (мада не
могу да смислим ниједан валидан разлог за то).

Ако желимо да пишемо фајл у неком другом кодирању (можда неки стари фајл)
можемо да

\startitemize[azbuka]

\item Конвертујемо фајл у UTF-8, што се препоручује, и за то постоје разни
алати; на Linux систему, на пример, команде {\tt iconv} или {\tt recode}.

\item Наведемо у изворном фајлу да кодирање није UTF-8. Да бисмо то урадили,
морамо да употребимо команду \tex{enableregime}, чија је синтакса:

\PlaceMacro{enableregime}{\tt \color[maincolor]{\backslash
enableregime[{\em Кодирање}]}}

где се {\em Кодирање} односи на име под којим систем \ConTeXt\ зна које је
стварно кодирање фајла у питању. У \in{табели}[encodings] ћете пронаћи
различита кодирања и имена под којим их зна систем \ConTeXt.

\stopitemize

{\switchtobodyfont[small]
  \placetable
    [here]
    [encodings]
    {Главна кодирања у систему \ConTeXt}
    {
      \starttabulate[|l|l|l|]
        \HL
        \NC {\bf Кодирање} \NC {\bf Име(на) у \ConTeXt} \NC{\bf Напомене}\NR
        \HL
        \NC Windows CP 1250\NC cp1250, windows-1250\NC Западноевропско\NR
        \NC Windows CP 1251\NC cp1251, windows-1251\NC Ћирилично\NR
        \NC Windows CP 1252\NC cp1252, win, windows-1252\NC Западноевропско\NR
        \NC Windows CP 1253\NC cp1253, windows-1253\NC Грчко\NR
        \NC Windows CP 1254\NC cp1254, windows-1254\NC Турско\NR
        \NC Windows CP 1257\NC cp1257, windows-1257\NC Балтичко\NR
        \NC ISO-8859-1, ISO Latin 1\NC iso-8859-1, latin1, il1\NC Западноевропско\NR
        \NC ISO-8859-2, ISO Latin 2\NC iso-8859-2, latin2, il2\NC Западноевропско\NR
        \NC ISO-8859-15, ISO Latin 9\NC iso-8859-15,  latin9,  il9\NC Западноевропско\NR
        \NC ISO-8859-7\NC iso-8859-7,  grk\NC Грчко\NR
        \NC Mac Roman\NC mac\NC Западноевропско\NR
        \NC IBM PC DOS\NC ibm\NC Западноевропско\NR
        \NC UTF-8\NC utf\NC Уникод\NR
        \NC VISCII\NC vis,  viscii\NC Вијетнамско\NR
        \NC DOS CP 866\NC cp866, cp866nav\NC Ћирилично\NR
        \NC KOI8\NC koi8-r, koi8-u, koi8-ru\NC Ћирилично\NR
        \NC Mac Cyrillic\NC maccyr, macukr\NC Ћирилично\NR
        \NC Остала\NC cp855, cp866av, cp866mav, cp866tat, \NC Разна\NR
        \NC \NC ctt, dbk, iso88595, isoir111, mik, mls, \NC\NR
        \NC \NC mnk, mos, ncc\NC\NR
        \HL
      \stoptabulate
    }
}

\ConTeXt\ Mk IV снажно препоручује употребу UTF-8. И ја се слажем са овом
препоруком. Од сада па надаље кроз овај увод, можемо претпоставити да је
кодирање увек UTF-8.

\startSmallPrint

  Уз команду \tex{enableregime} \ConTeXt\ има и команду
  \PlaceMacro{useregime}\tex{useregime} која нам омогућава да као њен
  аргумент наведемо кôд за једно или остала кодирања. Нисам пронашао никакве
  информације \Conjecture о овој команди, нити како се она разликује од
  \tex{enableregime}, већ само неке примере употребе.  Претпостављам да је
  \tex{useregime} дизајнирана за сложене пројекте који користе много изворних
  фајлова, уз очекивање да немају сви исто кодирање.  Али то је само
  нагађање.

\stopSmallPrint

\stopsection

\startsection
  [title=Карактери у изворном фајлу које \ConTeXt\ третира на посебан начин,
  bookmark=Карактери у изворном фајлу које ConTeXt третира на посебан начин]

{\em Специјални карактери} је име којим ћу називати групу карактера који се
разликују од {\em резервисаних карактера}. Као што смо видели у
\in{одељку}[sec:reserved characters], то су они који за систем \ConTeXt\ имају
посебно значење, тако да се не могу директно употребљавати као карактери у
изворном фајлу. Уз њих, постоји још једна група карактера која, мада их
\ConTeXt\ третира као такве када у изворном фајлу наиђе на њих, они се не
третирају посебним правилима. У овој групи се налазе размаци, табови, преломи
линија и цртице.

\startsubsection
  [title=Размаци и табови, reference=sec:spaces]

Табови и размаци се у изворном фајлу за све сврхе третирају на исти начин.
\ConTeXt\ ће таб карактер (Tab тастер на тастатури) трансформисати у празан
простор. А размаци се апсорбују у било који други празан простор (или таб) који
се налази непосредно иза њих. Тако да нема апсолутно никакве разлике ако у
изворном фајлу напишете

\type{Станлио и Олио.}

или

\type{Станлио   и   Олио.}

\ConTeXt{} сматра да су ове све реченице потпуно исте. Дакле, ако између речи
желимо да унесемо додатни размак, морамо да употребимо неке \ConTeXt{} команде
које то раде. Обично ће радити са \quotation{\cmd{\textvisiblespace}}, што
значи карактер {\tt\backslash} иза којег се налази размак. Али постоје и остале
процедуре у вези са хоризонталним размаком које ћемо представити у
\in{поглављу}[sec:horizontal space1].

Апсорпција узастопних размака нам омогућава да изворни фајл пишемо тако да
визуелно истакнемо делове које желимо да нагласимо, једноставно повећавајући
или умањујући употребљено увлачење, и да не бринемо јер знамо да то неће уопште
утицати на финални документ. Дакле, у следећем примеру

\starttyping

Музичка група из Мадрида с краја седмадесетих {\em La Romántica
  Banda Local} је писала песме еклетктичког стила које је било врло тешко
ставити у неку категорију. На пример, у својој песми „El Egipcio” су рекли: 
\quotation{{\em Esto es una farsa más que una comedia, página muy seria
  de la histeria musical; sueños de princesa, vicios de gitano pueden en
  su mano acariciar la verdad}}, мешајући речи, фразе, просто зато што
поседују унутрашњи ритам (comedia-histeria-seria, gitano-mano).

\stoptyping

можемо видети да су неке линије мало увучене удесно. То су линије које су део
фрагмената који би требало да се појаве у курзиву. Постојање ових увлачења
помаже (аутору) да види где се курзив завршава.

\startSmallPrint

  Неко би помислио, каква збрка! Морам ли да се замарам увлачењем линија?
  Истина је да ово посебно увлачење аутоматски ради мој едитор (GNU Emacs) када
  уређујем \ConTeXt\ изворни фајл. То је та врста мале помоћи услед које бирате
  да радите са неким едитором, а не са неким другим.

\stopSmallPrint

Правило апсорпције размака се примењује само на узастопне размаке у изворном
фајлу. Дакле, ако се у изворни фајл између два размака постави празна група
(\MyKey{\{\}}), мада она у финалном фајлу неће произвести ништа, њено присуство
ће обезбедити да два размака нису узастопна. На пример, ако напишемо
\MyKey{Станлио \{\} и Олио}, добићемо \quotation{\color[red]{Станлио {} и
Олио}}, где, ако пажљиво погледате, између прве две речи постоје два узастопна
размака.

Исто се дешава и са резервисаним карактером \MyKey{\lettertilde}, мада је његов
ефекат да генерише размак чак и ако то није: размак иза кога дође \lettertilde\
неће апсорбовати наредне, а неће ни размак након \lettertilde.

\stopsubsection

\startsubsection
  [reference=sec:linebreaks, title=Преломи линија]

Када линија достигне максималну ширину, у већини едитора се аутоматски уноси
прелом линије. Прелом линије можемо такође и експлицитно да унесемо тако што
притиснемо тастер \quotation{Ентер} или \quotation{Return}.

\ConTeXt{} примењује следећа правила у вези са преломом линије:

\startitemize[azbuka, broad]

\item За све намене, један прелом линије је исто што и размак. Дакле, ако се
непосредно испред или иза прелома линије нађе размак или таб, прелом линије или
први размак ће их апсорбовати, а у финални документ ће се уметнути прости
размак.

\item Два или више узастопна прелома линије креирају прелом пасуса. У овом
смислу, сматра се да су два прелома линије узастопна ако се између првог и
другог не налази ништа друго осим размака или табова (јер их први прелом линије
апсорбује); што укратко значи да једна или више узастопних линија које су у
изворном фајлу потпуно празне (без икаквих карактера или само са размацима или
табовима) постају прелом пасуса.

\stopitemize

Запазите да сам рекао \quotation{два или више узастопна прелома линије}, па
затим \quotation{једна или више празних узастопних линија}, што значи да ако
желимо да повећамо размак између пасуса, то не радимо једноставним уметањем још
једног прелома линије.  За то морамо да употребимо команду која повећава
вертикални размак. Ако нам треба само једна додатна линија раздвајања, можемо
да употребимо команду \PlaceMacro{blank}\tex{blank}. Али постоје и остале
процедуре за повећање вертикалног размака. Указујем на
\in{одељак}[sec:verticalspace].

\startSmallPrint

  Пошто прелом линије постаје размак, у неким приликама може да се јави неки
  нежељени и неочекивани размак. Посебно када пишемо макрое, јер је тада лако
  да се размак \quotation{ушуња} а да то не приметимо. Да бисмо то спречили,
  можемо употребити резервисани карактер \MyKey{\%} који, као што знамо, тамо
  где се појави спречава обраду линије, што повлачи да се не обрађује ни прелом
  на крају реда. Тако на пример, команда

%\vbox{
\starttyping
\define[3]\Test{
  {\em #1}
  {\bf #2}
  {\sc #3}
}
\stoptyping
%}

која свој први аргумент исписује у курзиву, други у црном слогу, а трећи
капиталом би уметнула размак између сваког од ових аргумената, док

\starttyping
\define[3]\Test{%
  {\em #1}%
  {\bf #2}%
  {\sc #3}%
}
\stoptyping

неће уметнути никакав размак између њих, јер резервисани карактер \% спречава
да се прелом линије обради, тако да он не постаје размак.

\stopSmallPrint

\stopsubsection

\startsubsection
  [reference=sec:dashes, title=Линије/црте]

Црте су добар пример разлике између компјутерске тастатуре и штампаног текста.
На нормалној тастатури, обично постоји само један карактер за црту (или линију
у типографском изразу) који зовемо цртица или (\MyKey{-}); али штампани текст
користи до четири различите дужине линија:

\startitemize[1,broad]

\item Кратке линије (цртице), као оне које служе за раздвајање речи на крају
реда (-).

\item Линије средње дужине (ен црте или ен линије), мало дуже од претходних
(–). Имају већи број примена, у неким европским језицима (не толико у
енглеском) означавају почетак линије дијалога, или раздвајају мањи од већег
броја опсега у датумима или страницама; \quotation{стр. 12–33}.

\item Дугачке линије (ем црте или ем линије) (—), користе се уместо заграда, за
укључивање једне реченице унутар друге.

\item Минус знак ($-$) за представљање одузимања или негативног броја.

\stopitemize

Данас је у UTF-8 кодирању доступно све горе наведено и још више. Али пошто још
увек не могу све да се генеришу притиском на један тастер на тастатури, није
тако једноставно да се уметну у изворни фајл. \TeX\ је на срећу увидео потребу
да се у финални документ умеће више врста линија/црта него што може да се
произведе тастатуром, па је дизајнирао просту процедуру за уметање.  \ConTeXt{}
је ту процедуру проширио додавањем команди које генеришу разне врсте линија. За
генерисање четири врсте линија можемо употребити два приступа: било обичан
\ConTeXt{} начин употребом команде, или директно са тастатуре. Ове процедуре су
приказане у \in{табели}[tbl:rules]:

{\switchtobodyfont[small]
\placetable
  [here]
  [tbl:rules]
  {Линије/црте у \ConTeXt}
  {\starttabulate[|l|c|c|l|]
    \HL
    \NC {\bf Врста линије}
    \NC {\bf Изглед}
    \NC {\bf Написана директно}
    \NC {\bf Команда}
    \NR
    \HL
    \NC Цртица
    \NC -
    \NC {\tt -}
    \NC \PlaceMacro{hyphen}\tex{hyphen}
    \NR
    \NC Ен линија
    \NC –
    \NC {\tt –}
    \NC \PlaceMacro{endash}\tex{endash}
    \NR
    \NC Ем линија
    \NC —
    \NC {\tt —}
    \NC \PlaceMacro{emdash}\tex{emdash}
    \NR
    \NC Знак минус
    \NC $-$
    \NC {\tt \$-\$}
    \NC \PlaceMacro{minus}\tex{minus}
    \NR
    \HL
  \stoptabulate}
}

Имена команди \tex{hyphen} и \tex{minus} су она која са обично користе у
енглеском језику. Мада их многи у штампарској индустрији називају
\quote{линије}, \TeX\ појмови, тачније \tex{endash} и \tex{emdash} су такође
уобичајени у словослагачкој терминологији. \quotation{{\em ен}} и
\quotation{{\em ем}} су имена мерних јединица које се користе у типографији.
\quotation{Ен} представља ширину карактера \quote{n}, док \quotation{ем}
представља ширину карактера \quote{m} у фонту који се тренутно користи.

\stopsection

\startsection
  [title=Прости пројекти и пројекти са више фајлова]

У систему \ConTeXt\ можемо да користимо само један изворни фајл у коме се
налази комплетан садржај финалног документа као и сви детаљи везани за њега, па
у том случају говоримо о \quotation{простим пројектима}, или супротно од тога,
могли бисмо да употребимо више изворних фајлова који деле садржај финалног
документа, па у том случају говоримо о \quotation{пројектима са више фајлова}.

Ситуације у којима је уобичајено да се ради са више изворних фајлова су
следеће:

\startitemize

\item Ако пишемо документ на којем сарађује више аутора, од којих сваки пише по
један део на којем ради само он; на пример, ако пишемо фестшрифт са прилозима
различитих аутора, или број неког журнала, итд.

\item Ако је документ на којем радимо, просто речено велики, тако да се
компјутер успори када га уређујемо или када га компајлирамо; у том случају,
подела материјала на неколико изворних фајлова у знатној мери убрзава
компајлирање сваког дела.

\item Исто тако, ако смо написали више макроа које желимо да применимо у неким
(или свим) нашим документима, или ако смо генерисали шаблон који контролише или
стилизује наше документе и хоћемо да га применимо на сваки документ, итд.

\stopitemize

\stopsection

\startsection
  [title=Структура изворног фајла у простим пројектима,
  reference=sec:structure]

Структура простих пројеката који се развијају само у једном изворном фајлу је
веома једноставна и заснива се око \MyKey{text} окружења које, у суштини, мора
да се појави у том истом фајлу. Разликујемо следеће делове фајла:

\startitemize

\item {\bf Преамбула документа}: све од прве линије фајла до почетка
\MyKey{text} окружења
(\PlaceMacro{starttext}\PlaceMacro{stoptext}\tex{starttext}).

\item {\bf Тело документа}: ово је саджај \MyKey{text} окружења; или другим
речима, све што се налази између \tex{starttext} и \tex{stoptext}.

\stopitemize

\placefigure
  [here]
  [img:ProyectoSimple]
  {\tfx фајл који садржи прости пројекат}
{\startframedtext
\starttyping
% Прва линија документа

% Област преамбуле:
% Садржи глобалне конфигурационе команде
% документа

\starttext % Овде почиње тело документа

...
... % Садржај документа
...

\stoptext % Крај документа

\stoptyping
\stopframedtext}

На \in{слици}[img:ProyectoSimple] видимо веома прост изворни фајл.  Потпуно све
испред команде \tex{starttext} (која је на слици у линији 5, ако се броје само
линије са текстом), чини преамбулу; све између \tex{starttext} и \tex{stoptext}
чини тело документа. Било шта након stoptext се игнорише.

{\bf Преамбула} се користи за уметање команди које треба да утичу на документ
као целину, односно оне које одређују његову глобалну конфигурацију.  Уопште
није обавезно да се у преамбули напише било каква команда. Ако ту нема команди,
\ConTeXt\ ће усвојити подразумевану конфигурацију која није баш детаљно
развијена, али ће послужити за многе документе. У добро планираним документима,
преамбула ће садржати све команде које утичу на документ као на целину, као што
су макрои и прилагођене команде које ће се користити у изворном фајлу. У
типичној преамбули, то би могло да изгледа овако:

\startitemize[packed]

\item Назначавање главног језика документа (погледајте
\in{одељак}[sec:langdoc]).

\item Назначавање величине папира (\in{одељак}[sec:papersize]) и распореда
стране (\in{одељак}[sec:pagelayout]).

\item Особине главног фонта документа (\in{одељак}[sec:mainfont]).

\item Прилагођавања section команди које ће се користити
(\in{одељак}[sec:setuphead]) и, ако је потребно, дефиницију нових section
команди (\in{одељак}[sec:definehead]).

\item Распоред заглавља и подножја (\in{одељак}[sec:headerfooter]).

\item Подешавања за наше нове личне макрое
(\in{одељак}[sec:definingcommands]).

\item Итд.

\stopitemize

Преамбула је намењена за глобалну конфигурацију документа; тако да ту не би
требало да буде ништа што се тиче {\em садржаја} документа, или текста који се
обрађује. У теорији, сав текст за обраду се у преамбули игнорише, мада понекад,
ако је ту, изазваће грешку компајлирања.

{\bf Тело документа}, окружено командама \tex{starttext} и \tex{stoptext}
садржи стварни садржај, што значи текст који се обрађује, заједно са \ConTeXt\
командама које не би требало да утичу на цео документ.

\stopsection

\startsection
  [title=Рад са више фајлова у \TeX\ стилу,
  bookmark=Рад са више фајлова у TeX стилу]

Да би омогућио рад са више изворних фајлова, \TeX\ је понудио примитиву која се
зове \tex{input}. Та примитива такође функционише и у систему \ConTeXt, мада он
прихвата и две специфичне команде које донекле усавршавају начин на који
функционише \tex{input}.

\startsubsection
  [reference=input, title=Команда \tex{input}]
\PlaceMacro{input}

Команда \tex{input} умеће садржај фајла који јој се проследи као аргумент.  Њен
формат је:

\type{\input ИмеФајла}

где је {\em ИмеФајла} име фајла који треба да се уметне. Обратите пажњу да име
не мора да се постави унутар витичастих заграда, мада се неће јавити грешка чак
и ако се то уради. Међутим, име никада не би требало поставити у велике
заграде. Ако је екстензија фајл \quotation{\type{.tex}}, може да се изостави.

Када \ConTeXt\ компајлира документ и наиђе на \tex{input} команду, он тражи
наведени фајл и наставља компајлирање као да је тај фајл био део фајла који га
учитава. Када заврши компајлирање, он се враћа у оригинални фајл и наставља са
места одакле је ушао у учитавани фајл; тако да је резултат, практично, као да
је садржај фајла наведеног у команди \tex{input} уметнут на место на којем се
она налази. Фајл који се позива командом \tex{input} мора имати важеће име у
нашем оперативном систему и не сме да садржи размаке. \ConTeXt\ ће га потражити
у радном директоријуму, па ако га ту не пронађе, потражиће га у директоријумима
наведеним у TEXROOT променљивој окружења. Ако се фајл на крају не пронађе,
вратиће се грешка компајлирања.

Најчешћа употреба \tex{input} команде изгледа овако: запише се фајл, назовимо
га \MyKey{glavni.tex}, који ће се користити као контејнер за позивање
\tex{input} командом разних фајлова који чине наш пројекат.  Ово је приказано у
следећем примеру:


\startframedtext\switchtobodyfont[small]
\starttyping
% Опште конфигурационе команде:

  \input MojaKonfiguracija

\starttext

  \input NaslovnaStrana
  \input Predgovor
  \input Glava1
  \input Glava2
  \input Glava3

  ...

\stoptext
\stoptyping
\stopframedtext

Запазите како смо за општу конфигурацију документа позвали фајл
\quotation{MojaKonfiguracija.tex} за који се претпоставља да садржи глобалне
команде које желимо да применимо. Затим, између команди \tex{starttext} и
\tex{stoptext} позивамо неколико фајлова у којима се налази садржај различитих
делова нашег документа. Ако у неком тренутку пожелимо да убрзамо процес
компајлирања, потребно је да изоставимо компајлирање неких фајлова, па је
потребно само да на почетак линије која позива одређени фајл ставимо знак
коментара.  На пример, ако пишемо треће поглавље и желимо да га компајлирамо
једноставно само да проверимо има ли у њему грешака, не морамо да компајлирамо
остатак, па можемо да напишемо:

\startframedtext\switchtobodyfont[small]
\starttyping
% Опште конфигурационе команде:

  \input MojaKonfiguracija

\starttext

  % \input NaslovnaStrana
  % \input Predgovor
  % \input Glava1
  % \input Glava2

  \input Glava3

  ...

\stoptext
\stoptyping
\stopframedtext

па ће се компајлирати само Глава 3. С друге стране, запазите да измена
редоследа поглавља значи једноставно измену редоследа линија које их позивају.

\startSmallPrint

  Када у пројекту који се састоји из више фајлова изузмемо неки  фајл из
  процеса компајлирања, добијамо на брзини обраде, али резултат тога је да све
  референце из дела који се не компајлира а указују на остале делове који још
  увек нису комајлирани неће више радити.  Погледајте
  \in{одељак}[sec:references].

\stopSmallPrint

Важно је да буде јасно да када радимо са командом \tex{input}, само главни
фајл, онај из којег се позивају сви остали, сме да садржи команде
\tex{starttext} и \tex{stoptext}, јер ако се налазе и у осталим фајловима,
јавиће се грешка компајлирања. С друге стране, ово значи да не можемо директно
да компајлирамо појединачне фајлове који чине пројекат, већ је неопходно да се
они компајлирају из главног фајла, то јест оног који наводи основну структуру
документа.

\stopsubsection

\startsubsection
  [title=\tex{ReadFile} и \tex{readfile}]
\PlaceMacro{ReadFile}\PlaceMacro{readfile}

Као што смо управо видели, ако \ConTeXt\ не пронађе фајл који се позива
командом \tex{input}, јавиће се грешка. У ситуацији када желимо да уметнемо
фајл само ако постоји, а дозвољава се и могућност да фајл можда не постоји,
\ConTeXt\ пружа варијацију команде \tex{input}. То је

\type{\ReadFile{ИмеФајла}}

Ова команда је слична команди \tex{input} у сваком погледу, осим што у случају
да се фајл не пронађе, компајлирање се наставља и не јавља се никаква грешка.
Такође се разликује од команде \tex{input} и по синтакси, јер знамо да за
\tex{input} није обавезно да се име фајла постави у витичасте заграде.  Али са
\tex{ReadFile} је то обавезно. Ако не употребимо витичасте заграде, \ConTeXt\
ће мислити да је име фајла који треба да нађе исто као и први карактер који
следи иза команде \tex{ReadFile}, уз екстензију \type{.tex}.  Тако да ако, на
пример, напишемо

\type{\ReadFile MojFajl}

\ConTeXt\ ће разумети да фајл који треба да прочита има име
\quotation{\type{M.tex}}, јер је карактер непосредно након команде
\tex{ReadFile} (изузимајући размаке који се, као што знамо, игноришу на крају
имена команде) \quote{M}. Пошто \ConTeXt\ у општем случају неће пронаћи фајл
под именом \quotation{\type{M.tex}}, а \tex{ReadFile} не генерише грешку ако не
пронађе фајл, \ConTeXt\ ће наставити компајлирање након \quote{M} у
\quotation{\type{MojFajl}}, па ће да уметне текст \quotation{\type{ojFajl}}.

\tex{readfile} је софистициранија верзија команде \tex{ReadFile} чији је формат

\type{\readfile{ИмеФајла}{ТекстАкоПостоји}{ТекстАкоНеПостоји}}

Први аргумент је сличан аргументу за \tex{ReadFile}: то је име фајла унутар
витичастих заграда. Други аргумент је текст који се исписује у случају да фајл
постоји, пре него него што се садржај фајла уметне. Трећи аргумент је текст
који се исписује ако се наведени фајл не пронађе. То значи да у зависности од
тога да ли се пронађе фајл наведен као први аргумент, извршавају се други (ако
фајл постоји), или трећи аргумент (ако фајл не постоји).

\stopsubsection

\stopsection

\startsection
  [title=\ConTeXt\ пројекти у ужем смислу,
  bookmark=ConTeXt пројекти у ужем смислу,
  reference=sec-projects]

Трећи механизам који систем \ConTeXt\ нуди за рад на пројектима са више фајлова
је сложенији и комплетнији: он почиње тако што се прави разлика између фајлова
пројекта, фајлова производа, фајлова компоненти и фајлова окружења.  Да бисмо
разумели међусобне везе и функцију сваког од ових типова, сматрам да је најбоље
објаснити сваки од њих појединачно:

\startsubsection
  [reference=environments, title={Фајлови {\em окружења}}]
\PlaceMacro{startenvironment}\PlaceMacro{environment}

Фајл окружења је фајл који чува макрое и конфигурације специфичних стилова
намењених да се примене на неколико докумената, било да су они потпуно
независни документи, било да су делови неког сложеног документа.  Дакле, фајл
окружења може да садржи све што бисмо иначе писали испред \tex{starttext}; то
јест: општу конфигурацију документа.

\startSmallPrint

За ове врсте фајлова сам задржао израз \quotation{фајлови окружења} како се не
бих удаљио од званичне \ConTeXt\ терминологије, мада верујем да би погоднији
израз вероватно био \quotation{фајлови формата} или \quotation{фајлови глобалне
конфигурације}.

\stopSmallPrint

Као и сви \ConTeXt\ изворни фајлови, фајлови окружења су текст фајлови који
подразумевају да је екстензија \quotation{\type{.tex}}, мада ако то желимо,
можемо да је променимо, највероватније на \quotation{\type{.env}}. Међутим, у
систему \ConTeXt\ се ово обично не ради.  Најчешће се фајл окружења препознаје
тако што почиње или се завршава са \quote{env}. На пример:
\quotation{\type{MojiMakroi_env.tex}} или
\quotation{\type{env_MojiMakroi.tex}}. Унутрашњост једног таквог фајла окружења
би могла да изгледа овако:

\startframedtext\switchtobodyfont[small]
\starttyping

\startenvironment MojeOkruzenje

  \mainlanguage[sr]

  \setupbodyfont
    [dejavu]

  \setupwhitespace
    [big]

  ...

\stopenvironment

\stoptyping
\stopframedtext

Или другим речима, дефиниције и конфигурационе команде се постављају између
\tex{startenvironment} и \tex{stopenvironment}. Непосредно иза
\tex{startenvironment} пишемо име којим називамо то окружење, па онда наводимо
све команде које треба да чине окружење.

\startSmallPrint

Што се тиче имена окружења, према резултатима мојих тестова, име које стављамо
непосредно иза \tex{startenvironment} је чисто индикативно, тако да и ако га не
наведемо, ништа (лоше) се не догађа.

\stopSmallPrint

Предвиђено је да фајлови окружења функционишу заједно са компонентама и
производима (који су објашњени у наредном одељку). То је разлог због којег
једно или више окружења може да се позове из компоненте или производа командом
\tex{environment}. Али ова команда такође ради и ако се употреби у
конфигурационој области (преамбули) било ког \ConTeXt\ изворног фајла, чак и
ако то није изворни фајл предвиђен да се компајлира у деловима.

Команда \tex{environment} може да се позове употребом било којег од следећа
два формата:

\type{\environment Фајл}

\type{\environment[Фајл]}

У сваком случају, резултат команде ће бити учитавање садржаја фајла који се
наведе као њен аргумент. Ако се тај фајл не пронађе, компајлирање ће се
наставити на уобичајен начин, без враћања било какве грешке. Ако је екстензија
фајла \quotation{\type{.tex}}, може да се изостави.

\stopsubsection

\startsubsection
  [reference=components and products, title=Компоненте и производи]
\PlaceMacro{startcomponent}\PlaceMacro{startproduct}\PlaceMacro{product}

Ако замислимо књигу у којој је свако поглавље у различитом изворном фајлу, онда
можемо да кажемо да су поглавља {\em компоненте}, а да је књига {\em производ}.
Ово значи да је {\em компонента} самостални део {\em производа}, који може да
поседује сопствени стил и може да се компајлира независно.  Свака компонента ће
имати различит фајл, а уз то ће постојати и фајл производа који обједињује све
компоненте у целину.

Типични фајл компоненте изгледа овако

\startframedtext\switchtobodyfont[small]
\starttyping

\environment MojeOkruzenje
\environment MojiMakroi

\startcomponent Glava1

  \startchapter[title={Глава 1}]

  ...

\stopcomponent

\stoptyping
\stopframedtext

А фајл производа би могао да изгледа овако:

\startframedtext\switchtobodyfont[small]
\starttyping

\environment MojeOkruzenje
\environment MojiMakroi

\startproduct MojaKnjiga

  \component Glava1
  \component Glava2
  \component Glava3

  ...

\stopproduct

\stoptyping
\stopframedtext

Запазите да ће стварни садржај нашег документа бити распоређен по разним
фајловима \quote{компоненти}, а да је фајл производа ограничен на успостављање
редоследа компоненти. С друге стране, (појединачне) компоненте и производи могу
директно да се компајлирају. Компајлирање производа ће генерисати PDF фајл који
садржи све компоненте тог производа.  А ако се компајлира појединачна
компонента, то ће генерисати PDF фајл који садржи само компоненту која се
компајлира.

Унутар фајла компоненте, пре команде \tex{startcomponent}, са \type{\environment 
ИмеОкружења} можемо да позовемо један или више фајлова окружења. Исто можемо да
урадимо и у фајлу производа, пре \tex{startproduct}. Истовремено може да се
учита неколико фајлова окружења.  На пример, можемо да имамо своју омиљену
колекцију макроа и разних стилова које примењујемо на документе који се налазе
у различитим фајловима.  Међутим, имајте на уму да када користимо два или више
окружења, она се учитавају у редоследу у којем су позивана, тако да ако се иста
конфигурациона команда налазу у више од једног окружења, а има различите
вредности, примениће се вредности оног последње учитаног. С друге стране,
окружења се учитавају само једном, тако да ако у претходним примерима у којима
се окружење позива из фајла производа и из одређених фајлова компоненти, ако
компајлирамо производ, то је тренутак учитавања окружења у редоследу у којем су
ту наведена; када се окружење позове из било које од компоненти, \ConTeXt\ ће
проверити да ли је окружење већ једном било учитано, па у том случају неће
урадити ништа.


Име компоненте која се позива из производа мора бити име фајла који садржи ту
компоненту, мада ако је екстензија тог фајла \quotation{\type{.tex}}, она може
да се изостави.

\stopsubsection

\startsubsection
  [title=Пројекти у ужем смислу]
\PlaceMacro{startproject}\PlaceMacro{project}

У већини случајева је разлика између производа и компоненти довољна. Исто тако,
\ConTeXt\ поседује чак и виши ниво у којем можемо да групишемо већи број
производа: то је {\em пројекат}.

Типични фајл пројекта би отприлике изгледао овако

\startframedtext\switchtobodyfont[small]
\starttyping

\startproject MojaKolekcija

  \environment MojeOkruzenje
  \environment MojiMakroi

  \product Knjiga1
  \product Knjiga2
  \product Knjiga3

  ...

\stopproject

\stoptyping
\stopframedtext

Сценарио у којем би нам био потребан пројекат је, на пример, онај у којем је
потребно да уредимо колекцију књига, све са истим спецификацијама формата; или
ако уређујемо неки журнал: таква колекција књига или журнала би била пројекат;
свака књига или сваки број журнала би био производ; а свако поглавље књиге или
сваки чланак у броју журнала би био компонента.

С друге стране, пројекти нису предвиђени да се директно компајлирају.  Имајте
на уму да би по дефиницији сваки производ који припада пројекту (свака књига у
колекцији, или сваки број журнала) требало да се компајлира одвојено и да се
генерише његов PDF. Стога се у њега поставља команда \tex{product} којом се
назначава који производи припадају неком пројекту, а која у суштини не ради
ништа: она је просто подсетник за аутора.

Јасно је да се неко може запитати зашто имамо пројекте ако не могу да се
компајлирају: одговор је зато што фајл пројекта везује одређена окружења за
пројекат. То је разлог што ће \ConTeXt, ако у фајл компоненте или производа
уметнемо команду \PlaceMacro{project}\tex{project ИмеПројекта}, да прочита фајл
пројекта и аутоматски да учита окружења везана за њега. Зато у пројектима
команда \tex{environment} мора да дође након \tex{startproject}; међутим, у
производима и компонентама, \tex{environment} мора да дође {\em пре}
\tex{startproduct} или \tex{startcomponent}.

Исто као и са командама \tex{environment} и \tex{component}, команда
\tex{project} нам омогућава да наведемо име пројекта било унутар великих
заграда, било да уопште не користимо велике заграде. Ово значи да су
\tex{project ИмеФајла} и \tex{Project[ИмеФајла]} еквивалентне команде.

{\bf Резиме различитих начина за учитавање окружења}

Из претходног следи да окружење може да се учита било којом од следећих
процедура:

\startitemize[azbuka, broad]

\item Уметањем команде \tex{environment ИмеОкружења} испред \cmd{starttext} или
\cmd{startcomponent}. То ће да учита окружење само за компајлирање тог фајла.

\item Уметањем команде \tex{environment ИмеОкружења} у фајл производа испред
\cmd{startproduct}. То ће да учита окружење када се компајлира производ, али
неће у случају да се његове компоненте компајлирају посебно.

\item Уметањем команде \tex{project} у производ или окружење: то ће да учита
сва окружења везана за пројекат (у фајлу пројекта).

\stopitemize

\stopsubsection

\startsubsection
  [title={Заједнички аспекти окружења,  компоненти, производа и пројеката}]

\startdescription{Имена окружења, компоненти, производа и пројеката:}

Већ смо видели да се, за све ове елементе, након \tex{start} команде која
започне одређено окружење, компоненту или производ, његово име мора ручно да се
наведе. Као правило, ово име мора да се подудара са именом фајла који садржи
окружење, компоненту ли производ јер, на пример, када \ConTeXt\ компајлира
производ, па сагласно са фајлом производа мора да учита окружење или
компоненту, не постоји начин да се зна који фајл представља то окружење или
компоненту осим ако фајл има исто име као и елемент који треба да се учита.

Иначе је, према резултатима мојих тестова, име које се пише након
\tex{startproduct} или \tex{startenvironment} у фајловима производа и окружења
чисто индикативно. Ако се изостави, или ако се не подудара са именом фајла, не
дешава се ништа лоше. Међутим, у случају компоненти је важно да се име
компоненте подудара са именом фајла који је садржи.

\stopdescription

\description{Структура директоријума пројекта:}

Знамо да \ConTeXt\ подразумевано тражи фајлове у радном директоријуму и на
путањи коју наводи променљива TEXROOT. Међутим, када користимо \tex{project},
\tex{product}, \tex{component} или \tex{environment} команде, претпоставља се
да пројекат има структуру директоријума у којој се заједнички елементи налазе у
директоријуму родитељу, а они специфични у неким дете директоријумима. Дакле,
ако се наведени фајл не пронађе у радном директоријуму, потражиће се у његовим
родитељ директоријумима, па ако се ни тамо не пронађе, у родитељ директоријуму
тог директоријума и тако даље.

\stopsubsection

\stopsection

\stopchapter

\stopcomponent
